{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00b6 What is Emmet \u00b6 Emmet is a toolkit of packages designed to build the Materials API. The Materials API is the specification of the Materials Project for defining and dissemenating \"materials documents\". The core document definitions live in emmet-core . The data pipelines that build these documents live in emmet-builders . A specialized multi-functional CLI to manage the orchestration of calculation ingestion, backup, and parsing is in emmet-cli . Emmet has been developed by the Materials Project (MP) team at Lawrence Berkeley Labs. Emmet is written in Python and supports Python 3.6+. Installation from PyPI \u00b6 Emmet is a toolkit. Due to a refactoring, emmet is in alpha status with no published metapackage. Only emmet-core is published on the Python Package Index . The preferred tool for installing packages from PyPi is pip . This tool is provided with all modern versions of Python. Open your terminal and run the following command. pip install --upgrade emmet-core Installation from source \u00b6 You can install Maggma directly from a clone of the Git repository . This can be done either by cloning the repo and installing from the local clone, or simply installing directly via git . shell tab=\"Local Clone\" git clone https://github.com//materialsproject/emmet cd emmet pip install -e emmet-core/","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"#what-is-emmet","text":"Emmet is a toolkit of packages designed to build the Materials API. The Materials API is the specification of the Materials Project for defining and dissemenating \"materials documents\". The core document definitions live in emmet-core . The data pipelines that build these documents live in emmet-builders . A specialized multi-functional CLI to manage the orchestration of calculation ingestion, backup, and parsing is in emmet-cli . Emmet has been developed by the Materials Project (MP) team at Lawrence Berkeley Labs. Emmet is written in Python and supports Python 3.6+.","title":"What is Emmet"},{"location":"#installation-from-pypi","text":"Emmet is a toolkit. Due to a refactoring, emmet is in alpha status with no published metapackage. Only emmet-core is published on the Python Package Index . The preferred tool for installing packages from PyPi is pip . This tool is provided with all modern versions of Python. Open your terminal and run the following command. pip install --upgrade emmet-core","title":"Installation from PyPI"},{"location":"#installation-from-source","text":"You can install Maggma directly from a clone of the Git repository . This can be done either by cloning the repo and installing from the local clone, or simply installing directly via git . shell tab=\"Local Clone\" git clone https://github.com//materialsproject/emmet cd emmet pip install -e emmet-core/","title":"Installation from source"},{"location":"CHANGELOG/","text":"Changelog \u00b6 v0.32.9 (2022-07-27) \u00b6 Full Changelog Merged pull requests: Permit electrodes with non-TM redox active species #484 ( acrutt ) Permitting Electrodes with Extractable Ions #483 ( acrutt ) Update Redox Elements #482 ( acrutt ) v0.32.8 (2022-07-27) \u00b6 Full Changelog Merged pull requests: Fix for incorrect collection name, require db_suffix to be set #485 ( mkhorton ) v0.32.7 (2022-07-26) \u00b6 Full Changelog Merged pull requests: Add timeout to MAPISettings class and pass to API resources #481 ( munrojm ) v0.32.6 (2022-07-25) \u00b6 Full Changelog Merged pull requests: Remove matminer as a dependency #480 ( mkhorton ) v0.32.5 (2022-07-25) \u00b6 Full Changelog Merged pull requests: Limit run types in thermo builder #479 ( munrojm ) v0.32.4 (2022-07-23) \u00b6 Full Changelog Merged pull requests: Update absorption.py #471 ( yang-ruoxi ) v0.32.3 (2022-07-23) \u00b6 Full Changelog Merged pull requests: Unpin pymatgen-analysis-alloys dependency #474 ( mkhorton ) v0.32.2 (2022-07-22) \u00b6 Full Changelog Merged pull requests: Bump pmg analysis alloys in setup #473 ( munrojm ) v0.32.1 (2022-07-21) \u00b6 Full Changelog Merged pull requests: Revert elasticity and chemenv data fields in SummaryDoc #470 ( munrojm ) v0.32.0 (2022-07-21) \u00b6 Full Changelog Merged pull requests: Fully incorporate new mixing scheme into the ThermoBuilder #467 ( munrojm ) v0.31.2 (2022-07-21) \u00b6 Full Changelog Merged pull requests: Bump pymatgen-analysis-alloys #469 ( mkhorton ) v0.31.1 (2022-07-19) \u00b6 Full Changelog Merged pull requests: Incorporate new mixing scheme into thermo builder #466 ( munrojm ) v0.31.0 (2022-07-19) \u00b6 Full Changelog Merged pull requests: Update for Alloys API #465 ( mkhorton ) v0.30.9 (2022-07-15) \u00b6 Full Changelog Merged pull requests: Warn for POTCAR hash issues and NSCF calculations #463 ( munrojm ) v0.30.8 (2022-07-14) \u00b6 Full Changelog Merged pull requests: Validate line-mode with uniform input set #462 ( munrojm ) Alloys integration #364 ( mkhorton ) v0.30.7 (2022-07-14) \u00b6 Full Changelog Merged pull requests: Add try except to valid input set generation #461 ( munrojm ) v0.30.6 (2022-07-14) \u00b6 Full Changelog Merged pull requests: Make sure input sets in validation builder get additional args #460 ( munrojm ) v0.30.5 (2022-07-13) \u00b6 Full Changelog Merged pull requests: Speed up TaskValidation #458 ( munrojm ) v0.30.4 (2022-07-13) \u00b6 Full Changelog Merged pull requests: Validation bugfix #457 ( munrojm ) v0.30.3 (2022-07-13) \u00b6 Full Changelog Merged pull requests: Build POTCAR hash cache in validation builder #456 ( munrojm ) v0.30.2 (2022-07-12) \u00b6 Full Changelog Merged pull requests: Change structure quality scores for materials builder #455 ( munrojm ) v0.30.1 (2022-07-12) \u00b6 Full Changelog Merged pull requests: Fix handling deformation tasks in materials builder #453 ( munrojm ) v0.30.0 (2022-07-12) \u00b6 Full Changelog Merged pull requests: Migrationgraphdoc #437 ( hmlli ) v0.29.5 (2022-07-12) \u00b6 Full Changelog Merged pull requests: Validation fixes #454 ( munrojm ) v0.29.4 (2022-07-08) \u00b6 Full Changelog Merged pull requests: Properly set potcar dir in validation #450 ( munrojm ) v0.29.3 (2022-07-07) \u00b6 Full Changelog Merged pull requests: Fix builder settings #449 ( munrojm ) v0.29.2 (2022-07-07) \u00b6 Full Changelog Merged pull requests: Add mobility utility functions #447 ( acrutt ) v0.29.1 (2022-07-07) \u00b6 Full Changelog Merged pull requests: Materials builder scan changes #448 ( munrojm ) v0.29.0 (2022-07-06) \u00b6 Full Changelog Merged pull requests: Add optic absorption builder #425 ( yang-ruoxi ) v0.28.4 (2022-06-27) \u00b6 Full Changelog Merged pull requests: Ensure electrode groups only pull non-deprecated materials #443 ( munrojm ) v0.28.3 (2022-06-27) \u00b6 Full Changelog Merged pull requests: Add strip_structures to Insertion Electrode Doc and Builder #439 ( acrutt ) v0.28.2 (2022-06-10) \u00b6 Full Changelog Merged pull requests: Add back legacy elasticity model #435 ( munrojm ) v0.28.1 (2022-06-08) \u00b6 Full Changelog Merged pull requests: Better handle formula and element issues #434 ( munrojm ) v0.28.0 (2022-06-07) \u00b6 Full Changelog Merged pull requests: Elasticity doc and builder #326 ( mjwen ) v0.27.8 (2022-06-07) \u00b6 Full Changelog Merged pull requests: Bump maggma #432 ( munrojm ) v0.27.7 (2022-06-06) \u00b6 Full Changelog Merged pull requests: Handle element and formula processing errors #431 ( munrojm ) v0.27.6 (2022-05-31) \u00b6 Full Changelog Merged pull requests: Fix facet memory issue with synthesis aggregation pipeline #430 ( munrojm ) Update the description for chemsys_permutations #424 ( acrutt ) v0.27.5 (2022-05-24) \u00b6 Full Changelog Merged pull requests: Rename molecules_old to molecules_jcesr #423 ( munrojm ) v0.27.4 (2022-05-20) \u00b6 Full Changelog Merged pull requests: Allow tags to be None in validation #419 ( munrojm ) v0.27.3 (2022-05-19) \u00b6 Full Changelog Merged pull requests: Fix tags field in task document #418 ( munrojm ) v0.27.2 (2022-05-13) \u00b6 Full Changelog Merged pull requests: Fix calcs_reversed and output structure #417 ( munrojm ) v0.27.1 (2022-05-13) \u00b6 Full Changelog Merged pull requests: Fix validation projection #416 ( munrojm ) v0.27.0 (2022-05-12) \u00b6 Full Changelog Merged pull requests: Add quantities associated with get_decomp_and_phase_separation_energy #408 ( mkhorton ) v0.26.3 (2022-05-11) \u00b6 Full Changelog Merged pull requests: Take absolute value for magnetic moment validation #415 ( munrojm ) v0.26.2 (2022-05-11) \u00b6 Full Changelog Merged pull requests: Rename old molecules module #414 ( munrojm ) v0.26.1 (2022-05-05) \u00b6 Full Changelog Closed issues: Rename Status enum for molecule tasks #412 Deprecation rule for unphysical magnetic moments #410 Update emmet-builders requirements.txt #329 Merged pull requests: Single atom fix #413 ( espottesmith ) v0.26.0 (2022-05-05) \u00b6 Full Changelog Merged pull requests: Updated deprecation rules, chemenv API endpoint and data, and entries sub-url #411 ( munrojm ) v0.25.0 (2022-05-05) \u00b6 Full Changelog Merged pull requests: [WIP] New data models and builders for molecules #334 ( espottesmith ) v0.24.5 (2022-04-26) \u00b6 Full Changelog Merged pull requests: Switch to using the full MaterialsDoc in the API #404 ( munrojm ) v0.24.4 (2022-04-26) \u00b6 Full Changelog Merged pull requests: Only run doc build after tests pass #401 ( munrojm ) v0.24.3 (2022-04-25) \u00b6 Full Changelog Merged pull requests: Support R2SCAN, SCAN and PBESol tasks in the new build system #236 ( rkingsbury ) v0.24.2 (2022-04-21) \u00b6 Full Changelog Merged pull requests: Bump maggma to fix key endpoint projection issues #398 ( munrojm ) v0.24.1 (2022-04-20) \u00b6 Full Changelog Merged pull requests: Add projection field for charge densities #397 ( munrojm ) v0.24.0 (2022-04-19) \u00b6 Full Changelog Merged pull requests: API S3 object endpoint changes #396 ( munrojm ) v0.23.0 (2022-04-14) \u00b6 Full Changelog Closed issues: Set header to allow for load-testing via continuous integration to bypass CF rate limiting #380 Merged pull requests: Core model and operator improvements, overhaul of pagination params #368 ( munrojm ) v0.22.0 (2022-04-13) \u00b6 Full Changelog Merged pull requests: ChemEnv integration #379 ( JaGeo ) v0.21.27 (2022-04-08) \u00b6 Full Changelog Merged pull requests: Fix material sorting post-process #391 ( munrojm ) Incorrect parameters for hybrid functionals #389 ( nwinner ) v0.21.26 (2022-04-07) \u00b6 Full Changelog Merged pull requests: Add `electronic_steps' to trajectory endpoint and fix structure frame population #390 ( munrojm ) v0.21.25 (2022-04-07) \u00b6 Full Changelog Merged pull requests: Fix structure key handling in trajectory endpoint #388 ( munrojm ) v0.21.24 (2022-04-06) \u00b6 Full Changelog Merged pull requests: Handle trajectory and element dict and value errors #387 ( munrojm ) v0.21.23 (2022-04-06) \u00b6 Full Changelog Merged pull requests: General store post_process bug fix #386 ( munrojm ) v0.21.22 (2022-04-06) \u00b6 Full Changelog Merged pull requests: Enhance post-processing to avoid overwrite issues #385 ( munrojm ) v0.21.21 (2022-03-25) \u00b6 Full Changelog Merged pull requests: Trajectory endpoint fix #382 ( munrojm ) v0.21.20 (2022-02-23) \u00b6 Full Changelog Merged pull requests: Return proper error response in autocomplete endpoint #373 ( munrojm ) v0.21.19 (2022-01-28) \u00b6 Full Changelog Merged pull requests: Fix task doc composition validation issue in API #363 ( munrojm ) v0.21.18 (2022-01-21) \u00b6 Full Changelog Merged pull requests: Battery formula patch + pydantic fix #356 ( munrojm ) v0.21.17 (2022-01-20) \u00b6 Full Changelog Merged pull requests: Electrodes model fix #355 ( munrojm ) v0.21.16 (2022-01-20) \u00b6 Full Changelog Merged pull requests: Remove version req in setup #354 ( munrojm ) Fix setup for workflow #353 ( munrojm ) v0.21.15 (2022-01-19) \u00b6 Full Changelog v0.21.14 (2022-01-19) \u00b6 Full Changelog Merged pull requests: Fix release workflow #352 ( munrojm ) v0.21.13 (2022-01-19) \u00b6 Full Changelog Merged pull requests: Revert nesting _verison.py #351 ( munrojm ) v0.21.12 (2022-01-19) \u00b6 Full Changelog Merged pull requests: Revert to get_distribution in init #349 ( munrojm ) v0.21.10 (2022-01-19) \u00b6 Full Changelog v0.21.11 (2022-01-19) \u00b6 Full Changelog Merged pull requests: Move _version.py further into package to fix import issues #348 ( munrojm ) v0.21.9 (2022-01-19) \u00b6 Full Changelog Merged pull requests: Git stash added to docs step #347 ( munrojm ) v0.21.7 (2022-01-19) \u00b6 Full Changelog v0.21.8 (2022-01-19) \u00b6 Full Changelog Merged pull requests: Git pull added to docs #346 ( munrojm ) v0.21.6 (2022-01-19) \u00b6 Full Changelog Merged pull requests: Fix git pull command in workflow #345 ( munrojm ) v0.21.5 (2022-01-19) \u00b6 Full Changelog Merged pull requests: Git pull to sync between namespace steps #344 ( munrojm ) v0.21.4 (2022-01-19) \u00b6 Full Changelog Merged pull requests: Version file generation pushed into namespace packages #343 ( munrojm ) v0.21.3 (2022-01-15) \u00b6 Full Changelog Merged pull requests: Revert version update to release workflow with conditionals #340 ( munrojm ) v0.21.2 (2022-01-15) \u00b6 Full Changelog Merged pull requests: Alter commit message in actions #339 ( munrojm ) Fix version push in actions #338 ( munrojm ) v0.21.1 (2022-01-15) \u00b6 Full Changelog Merged pull requests: Alter how version is determined #337 ( munrojm ) v0.21.0 (2022-01-13) \u00b6 Full Changelog Merged pull requests: Chemsys, electrode, provenance, and robocrys changes #336 ( munrojm ) Allow for parsing of material docs without GGA/GGA+U (i.e. without corrections) #335 ( arosen93 ) v0.20.3 (2022-01-07) \u00b6 Full Changelog Merged pull requests: Substrates patch #332 ( munrojm ) v0.20.2 (2022-01-07) \u00b6 Full Changelog Merged pull requests: Bump min maggma version #330 ( munrojm ) v0.20.1 (2022-01-06) \u00b6 Full Changelog Merged pull requests: Add dockerfile for emmet api #328 ( munrojm ) v0.20.0 (2022-01-06) \u00b6 Full Changelog Closed issues: Elastic builder #245 Merged pull requests: Emmet API package #327 ( munrojm ) v0.19.1 (2021-12-21) \u00b6 Full Changelog Merged pull requests: Electrode host structure bug fix #323 ( munrojm ) v0.19.0 (2021-12-20) \u00b6 Full Changelog Merged pull requests: Electrode builder updates #322 ( munrojm ) v0.18.0 (2021-11-24) \u00b6 Full Changelog Merged pull requests: General builder updates #317 ( munrojm ) v0.17.0 (2021-11-17) \u00b6 Full Changelog Merged pull requests: Update emmet meta #313 ( munrojm ) v0.16.0 (2021-11-13) \u00b6 Full Changelog Merged pull requests: Initial commit of similarity builder #310 ( munrojm ) v0.15.16 (2021-11-12) \u00b6 Full Changelog Merged pull requests: Fix default phase diagram value #309 ( munrojm ) v0.15.15 (2021-11-12) \u00b6 Full Changelog Merged pull requests: Remove store query for phase diagram data #308 ( munrojm ) v0.15.14 (2021-11-11) \u00b6 Full Changelog Merged pull requests: Add element number cap to phase diagram generation in thermo #307 ( munrojm ) v0.15.13 (2021-11-09) \u00b6 Full Changelog Merged pull requests: Remove summary sub docs to fix magnetism and polar data #306 ( munrojm ) v0.15.12 (2021-11-08) \u00b6 Full Changelog Merged pull requests: Include charge_density in summary has_props #305 ( munrojm ) v0.15.11 (2021-11-02) \u00b6 Full Changelog Merged pull requests: Final polar builder updates #303 ( munrojm ) Remove chunking methods from test coverage for materials and thermo #302 ( munrojm ) v0.15.10 (2021-11-01) \u00b6 Full Changelog Merged pull requests: Patch fix correct tensor variable in dielectric #301 ( munrojm ) v0.15.9 (2021-11-01) \u00b6 Full Changelog Merged pull requests: Ensure DFPT tasks in polar builders #300 ( munrojm ) v0.15.8 (2021-10-31) \u00b6 Full Changelog Merged pull requests: Remove output structure from polar builders #298 ( munrojm ) v0.15.7 (2021-10-29) \u00b6 Full Changelog Merged pull requests: Convert structure inside bonds builder #297 ( munrojm ) v0.15.6 (2021-10-29) \u00b6 Full Changelog Merged pull requests: Reference proper structure in polar builders #296 ( munrojm ) v0.15.5 (2021-10-28) \u00b6 Full Changelog Merged pull requests: Fix piezo model #295 ( munrojm ) v0.15.4 (2021-10-27) \u00b6 Full Changelog Merged pull requests: Fix grouper bug #294 ( munrojm ) v0.15.3 (2021-10-27) \u00b6 Full Changelog Merged pull requests: Structure grouper chemsys chunk fix #292 ( munrojm ) v0.15.2 (2021-10-25) \u00b6 Full Changelog Merged pull requests: Chunk with chemsys in structure group builder #289 ( munrojm ) v0.15.1 (2021-10-25) \u00b6 Full Changelog Merged pull requests: Fix electrode chunking #288 ( munrojm ) v0.15.0 (2021-10-22) \u00b6 Full Changelog Merged pull requests: Magnetism builder updates #286 ( munrojm ) v0.14.6 (2021-10-21) \u00b6 Full Changelog Merged pull requests: Builder chunking fixes #287 ( munrojm ) v0.14.5 (2021-10-15) \u00b6 Full Changelog Merged pull requests: Optimize phase diagram building in the thermo builder #283 ( munrojm ) v0.14.4 (2021-10-14) \u00b6 Full Changelog Merged pull requests: thermo builder bugs #282 ( acrutt ) v0.14.3 (2021-10-13) \u00b6 Full Changelog Merged pull requests: ThermoDoc.from_entries() energy fix #281 ( acrutt ) v0.14.2 (2021-10-12) \u00b6 Full Changelog Merged pull requests: ComputedStructureEntry type consistency #279 ( acrutt ) v0.14.1 (2021-10-12) \u00b6 Full Changelog Merged pull requests: Fix phase diagram ensure index #280 ( munrojm ) v0.14.0 (2021-10-11) \u00b6 Full Changelog Merged pull requests: Update dielectric, piezoelectric and thermo builders #278 ( munrojm ) v0.13.3 (2021-09-28) \u00b6 Full Changelog Merged pull requests: Summary additions and fixes #276 ( munrojm ) v0.13.2 (2021-09-25) \u00b6 Full Changelog Merged pull requests: Elements to chemsys in validation check #274 ( munrojm ) v0.13.1 (2021-09-24) \u00b6 Full Changelog Merged pull requests: Small builder changes #273 ( munrojm ) v0.13.0 (2021-09-23) \u00b6 Full Changelog Merged pull requests: Builder bug fixes #272 ( munrojm ) v0.12.8 (2021-09-15) \u00b6 Full Changelog v0.12.7 (2021-09-15) \u00b6 Full Changelog Merged pull requests: Remove phase diagram from thermo doc and builder #270 ( munrojm ) v0.12.6 (2021-09-14) \u00b6 Full Changelog Merged pull requests: Materials and thermo builder fixes #269 ( munrojm ) v0.12.5 (2021-09-09) \u00b6 Full Changelog Merged pull requests: Chunking bug fix #265 ( munrojm ) v0.12.4 (2021-09-09) \u00b6 Full Changelog Merged pull requests: Fix pre-chunking for materials and thermo builder #264 ( munrojm ) v0.12.3 (2021-09-09) \u00b6 Full Changelog Merged pull requests: Fix material builder #263 ( munrojm ) v0.12.2 (2021-09-02) \u00b6 Full Changelog Merged pull requests: Validation builder U fix #257 ( munrojm ) v0.12.1 (2021-09-02) \u00b6 Full Changelog Merged pull requests: Provenance to summary #256 ( munrojm ) v0.12.0 (2021-09-02) \u00b6 Full Changelog Merged pull requests: Provenance overhaul #255 ( munrojm ) v0.11.0 (2021-08-26) \u00b6 Full Changelog Merged pull requests: Builder updates for legacy data parity #249 ( munrojm ) v0.10.0 (2021-08-19) \u00b6 Full Changelog Merged pull requests: Deprecation data added to PropertyDoc #247 ( munrojm ) v0.9.3 (2021-08-05) \u00b6 Full Changelog Merged pull requests: Fix property doc names #241 ( shyamd ) v0.9.2 (2021-08-05) \u00b6 Full Changelog Closed issues: feature: build data in all models #202 Merged pull requests: fix bugs in MPID #240 ( rkingsbury ) v0.9.1 (2021-07-26) \u00b6 Full Changelog Merged pull requests: Revert structure back to using computed structure #239 ( shyamd ) v0.9.0 (2021-07-23) \u00b6 Full Changelog Closed issues: Fix and standardize settings context var #237 Build data in document model #232 Thoughts on having StructureNL instead of Structure in canonical materials structure field? #97 Merged pull requests: New EmmetBaseModel #235 ( shyamd ) Substrates #231 ( shyamd ) Optimade Materials Doc #230 ( shyamd ) v0.8.3 (2021-07-20) \u00b6 Full Changelog Fixed bugs: Oxidation state composition fields not serialized properly #216 Closed issues: Feature Request: Robocrystallographer #208 Rotate structure to standard convention #111 Returned docs too large for common API queries (third-order elasticity) #76 Merged pull requests: Better Provenance Management #228 ( shyamd ) v0.8.2 (2021-07-16) \u00b6 Full Changelog Merged pull requests: Summary field bug fix #226 ( munrojm ) v0.8.1 (2021-07-15) \u00b6 Full Changelog Merged pull requests: Rename summary stats model #225 ( munrojm ) v0.8.0 (2021-07-15) \u00b6 Full Changelog Merged pull requests: Electronic structure and search builder updates #221 ( munrojm ) v0.7.2 (2021-07-15) \u00b6 Full Changelog Merged pull requests: Fix Deprecated Materials Speed #224 ( shyamd ) v0.7.1 (2021-07-13) \u00b6 Full Changelog v0.7.0 (2021-07-13) \u00b6 Full Changelog Merged pull requests: Robocrystallographer document #222 ( shyamd ) v0.6.0 (2021-07-12) \u00b6 Full Changelog Merged pull requests: Add Deprecated Materials to MaterialsDoc construction #220 ( shyamd ) Fix provenance #219 ( shyamd ) v0.5.0 (2021-07-02) \u00b6 Full Changelog Merged pull requests: Fix Validation #215 ( shyamd ) v0.4.1 (2021-06-27) \u00b6 Full Changelog Merged pull requests: Fix oxidation doc composition #217 ( shyamd ) v0.4.0 (2021-06-24) \u00b6 Full Changelog Merged pull requests: Add R2SCAN to run_types #214 ( shyamd ) v0.3.6 (2021-06-24) \u00b6 Full Changelog Merged pull requests: Fix projection for vasp run_type determination #213 ( shyamd ) v0.3.5 (2021-06-24) \u00b6 Full Changelog Merged pull requests: Fix run_type in validation #212 ( shyamd ) v0.3.4 (2021-06-23) \u00b6 Full Changelog Merged pull requests: Bug: Reference the last calculation to determine run_type #211 ( shyamd ) v0.3.3 (2021-06-23) \u00b6 Full Changelog Merged pull requests: Remove bson package requirement #209 ( shyamd ) v0.3.2 (2021-06-21) \u00b6 Full Changelog Merged pull requests: Electronic Structure model and builder fixes #206 ( munrojm ) v0.3.1 (2021-06-21) \u00b6 Full Changelog Merged pull requests: Use deprecated tasks in Materials Builder #207 ( shyamd ) v0.3.0 (2021-06-16) \u00b6 Full Changelog Merged pull requests: Release Emmet Builders #205 ( shyamd ) v0.2.4 (2021-06-14) \u00b6 Full Changelog Merged pull requests: Revert materials finding to old pipeline behavior #203 ( shyamd ) v0.2.3 (2021-06-07) \u00b6 Full Changelog Merged pull requests: Fix oxidation document #201 ( shyamd ) v0.2.2 (2021-06-04) \u00b6 Full Changelog v0.2.1 (2021-06-03) \u00b6 Full Changelog Merged pull requests: Reconcile changes on updates branch #199 ( shyamd ) Oxidation State Document #198 ( shyamd ) Move XAS Logic into document and clean up builder #197 ( shyamd ) Electronic structure and search components #189 ( munrojm ) v0.2.0 (2021-05-10) \u00b6 Full Changelog Closed issues: Bug: set's get serialized into set() rather than a list #183 task_type is moved to vasp/calc_type #121 Merged pull requests: various fixes to structure grouper an electrode documents and builders #178 ( jmmshn ) Updated materials and thermo builder #177 ( jmmshn ) Provenance Builder #176 ( shyamd ) relaxed enforced type of orig_input #175 ( jmmshn ) Fix serialization and update validation #174 ( shyamd ) Working Thermo Builder #170 ( jmmshn ) Add SCF gradient and Manual deprecation to VASP validation #169 ( shyamd ) Create MPID Type #167 ( shyamd ) Remove stubs in favor of monty pydantic compatability #165 ( shyamd ) made structure grouper work with material_ids #163 ( jmmshn ) minor changes to get material builder working on non-production databases. #162 ( jmmshn ) Electrode Doc #149 ( jmmshn ) Structure Group Docs and Builder #148 ( jmmshn ) Generate static run-types for IDEs #141 ( shyamd ) Added CrossRef builder #133 ( jmmshn ) Sanitize Enums #132 ( utf ) Use lattice model #131 ( utf ) cli: restoring tasks (bugfixes) #119 ( tschaume ) Emmet-Core Docs #117 ( shyamd ) Initial Documentation Structure #116 ( shyamd ) v0.1.1-alpha (2020-04-19) \u00b6 Full Changelog v0.1-alpha (2020-04-19) \u00b6 Full Changelog Closed issues: Conflicts in electrodes.py #108 Band gaps being reported differently from those described by mapidoc / the old builders #62 KeyError when running lu_field with a store already containing data #45 VaspDrone for emmet? #40 Merged pull requests: fixes for electrode builder #113 ( jmmshn ) Updates for the latest DB release #110 ( shyamd ) Working insertion electrodes builder #109 ( jmmshn ) Production updates for September 2019 #107 ( shyamd ) Update ICSD drone #105 ( kmu ) Change magnetism builder to build from tasks #104 ( mkhorton ) CLI: primitive structures, zip support, SNLs #101 ( tschaume ) Added StructurePredictionBuilder #98 ( mattmcdermott ) WIP: Initial creation of defects emmet builder #95 ( dbroberg ) WIP: Acceptance tests for deprecation guarding etc. #94 ( dwinston ) missing and (how did this work?) #93 ( tschaume ) Fix a bug in bond_valence #92 ( kmu ) bug fix #90 ( jmmshn ) Central repository for global variables #88 ( mkhorton ) WIP March Production Updates #87 ( shyamd ) Fixed sandbox bug and cleaned up #84 ( jmmshn ) Website Updates #82 ( shyamd ) Update to electrode builder to match the data required by the website builder #81 ( jmmshn ) Robocrystallographer audio builder #79 ( dwinston ) Build structure visualization JSON #78 ( mkhorton ) Add robocrys version to builder doc #75 ( utf ) Add robocrystallographer builder #74 ( utf ) [WIP] MPComplete status #73 ( dwinston ) Production Updates #72 ( shyamd ) fix: snl history is a list #70 ( dwinston ) Maggma update #69 ( shyamd ) [WIP] Update magnetic grouping #67 ( mkhorton ) Battery builder (work in progress) #66 ( jmmshn ) Production Updates #65 ( shyamd ) [WIP] Updates to magnetism, bond, mp_website builders, new bond_valence, mp_website_digest builders #64 ( mkhorton ) mp website update for propnet and toecs #63 ( montoyjh ) big elastic PR #61 ( montoyjh ) Added meta data & unit tests #60 ( nisse3000 ) Added composition descritpors for similarity toolbox #59 ( nisse3000 ) Fix 'magnestism' typo #58 ( mkhorton ) Removed min and max statistics from structure fingerprint #57 ( nisse3000 ) Updated site-descriptor calculation to reflect best settings. #56 ( nisse3000 ) [WIP] x-ray absorption spectra builder updates #55 ( dwinston ) Requested site-descriptor changes #53 ( nisse3000 ) Install openbabel in test env #52 ( dwinston ) More Updates for MP Website #49 ( shyamd ) Avoid hardcoding local settings path on serialization #48 ( dwinston ) Added BoltztrapDosBuilder class #42 ( fraricci ) [WIP] Command Line Interface #41 ( tschaume ) v2018.6.7 (2018-06-07) \u00b6 Full Changelog v2018.6.6 (2018-06-06) \u00b6 Full Changelog Merged pull requests: Updates #47 ( shyamd ) Fix diffraction builder. Add test for fixed method. #46 ( dwinston ) Replace TopologyBuilder with BondBuilder #44 ( mkhorton ) Copybuilder additions #43 ( montoyjh ) Massive amounts of refactoring in main builders #39 ( shyamd ) Adaptions to new pymatgen version and requiring most recent pymatgen version #37 ( nisse3000 ) Fixes a few issues in wf builder and elastic builder #36 ( montoyjh ) Copybuilder bug - tqdm doesn't play nicely with next() #35 ( montoyjh ) Add tests for copybuilder. Was using old store attr lu_key . #34 ( dwinston ) README: editable install #33 ( tschaume ) Property workflow builder #32 ( montoyjh ) v2018.4.2 (2018-04-02) \u00b6 Full Changelog Closed issues: A generalized warning generator for task documents? #26 Merged pull requests: Changed site-descriptor data structure & adapted structure similarity builder accordingly #31 ( nisse3000 ) Massive reorganization #28 ( shyamd ) Corrected setup.py #27 ( nisse3000 ) v2018.3.9 (2018-03-09) \u00b6 Full Changelog Closed issues: SurfacePropertiesBuilder #23 Merged pull requests: Massive changeset for Production #25 ( shyamd ) Restructured site-descriptor storage #24 ( nisse3000 ) Added a site-descriptor builder #22 ( nisse3000 ) Builder updates (topology) #21 ( mkhorton ) Compatibility and elastic builders #20 ( montoyjh ) Fix substrates builder #18 ( dwinston ) abinit phonon builder #16 ( gpetretto ) v2018.1.1 (2017-12-16) \u00b6 Full Changelog v2017.11.8 (2017-11-07) \u00b6 Full Changelog Closed issues: PyPi package #2 Merged pull requests: Readme update #15 ( mkhorton ) Initial topology builder #10 ( mkhorton ) Small update to README #9 ( mkhorton ) Small README update #8 ( mkhorton ) ICSD drone #7 ( JPalakapilly ) Fix sample script in README #6 ( mkhorton ) Minor doc update #5 ( mkhorton ) Initial commit for some documentation (in progress) #4 ( mkhorton ) Materials builder #3 ( shyamd ) Task tagger #1 ( shyamd ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#v0329-2022-07-27","text":"Full Changelog Merged pull requests: Permit electrodes with non-TM redox active species #484 ( acrutt ) Permitting Electrodes with Extractable Ions #483 ( acrutt ) Update Redox Elements #482 ( acrutt )","title":"v0.32.9 (2022-07-27)"},{"location":"CHANGELOG/#v0328-2022-07-27","text":"Full Changelog Merged pull requests: Fix for incorrect collection name, require db_suffix to be set #485 ( mkhorton )","title":"v0.32.8 (2022-07-27)"},{"location":"CHANGELOG/#v0327-2022-07-26","text":"Full Changelog Merged pull requests: Add timeout to MAPISettings class and pass to API resources #481 ( munrojm )","title":"v0.32.7 (2022-07-26)"},{"location":"CHANGELOG/#v0326-2022-07-25","text":"Full Changelog Merged pull requests: Remove matminer as a dependency #480 ( mkhorton )","title":"v0.32.6 (2022-07-25)"},{"location":"CHANGELOG/#v0325-2022-07-25","text":"Full Changelog Merged pull requests: Limit run types in thermo builder #479 ( munrojm )","title":"v0.32.5 (2022-07-25)"},{"location":"CHANGELOG/#v0324-2022-07-23","text":"Full Changelog Merged pull requests: Update absorption.py #471 ( yang-ruoxi )","title":"v0.32.4 (2022-07-23)"},{"location":"CHANGELOG/#v0323-2022-07-23","text":"Full Changelog Merged pull requests: Unpin pymatgen-analysis-alloys dependency #474 ( mkhorton )","title":"v0.32.3 (2022-07-23)"},{"location":"CHANGELOG/#v0322-2022-07-22","text":"Full Changelog Merged pull requests: Bump pmg analysis alloys in setup #473 ( munrojm )","title":"v0.32.2 (2022-07-22)"},{"location":"CHANGELOG/#v0321-2022-07-21","text":"Full Changelog Merged pull requests: Revert elasticity and chemenv data fields in SummaryDoc #470 ( munrojm )","title":"v0.32.1 (2022-07-21)"},{"location":"CHANGELOG/#v0320-2022-07-21","text":"Full Changelog Merged pull requests: Fully incorporate new mixing scheme into the ThermoBuilder #467 ( munrojm )","title":"v0.32.0 (2022-07-21)"},{"location":"CHANGELOG/#v0312-2022-07-21","text":"Full Changelog Merged pull requests: Bump pymatgen-analysis-alloys #469 ( mkhorton )","title":"v0.31.2 (2022-07-21)"},{"location":"CHANGELOG/#v0311-2022-07-19","text":"Full Changelog Merged pull requests: Incorporate new mixing scheme into thermo builder #466 ( munrojm )","title":"v0.31.1 (2022-07-19)"},{"location":"CHANGELOG/#v0310-2022-07-19","text":"Full Changelog Merged pull requests: Update for Alloys API #465 ( mkhorton )","title":"v0.31.0 (2022-07-19)"},{"location":"CHANGELOG/#v0309-2022-07-15","text":"Full Changelog Merged pull requests: Warn for POTCAR hash issues and NSCF calculations #463 ( munrojm )","title":"v0.30.9 (2022-07-15)"},{"location":"CHANGELOG/#v0308-2022-07-14","text":"Full Changelog Merged pull requests: Validate line-mode with uniform input set #462 ( munrojm ) Alloys integration #364 ( mkhorton )","title":"v0.30.8 (2022-07-14)"},{"location":"CHANGELOG/#v0307-2022-07-14","text":"Full Changelog Merged pull requests: Add try except to valid input set generation #461 ( munrojm )","title":"v0.30.7 (2022-07-14)"},{"location":"CHANGELOG/#v0306-2022-07-14","text":"Full Changelog Merged pull requests: Make sure input sets in validation builder get additional args #460 ( munrojm )","title":"v0.30.6 (2022-07-14)"},{"location":"CHANGELOG/#v0305-2022-07-13","text":"Full Changelog Merged pull requests: Speed up TaskValidation #458 ( munrojm )","title":"v0.30.5 (2022-07-13)"},{"location":"CHANGELOG/#v0304-2022-07-13","text":"Full Changelog Merged pull requests: Validation bugfix #457 ( munrojm )","title":"v0.30.4 (2022-07-13)"},{"location":"CHANGELOG/#v0303-2022-07-13","text":"Full Changelog Merged pull requests: Build POTCAR hash cache in validation builder #456 ( munrojm )","title":"v0.30.3 (2022-07-13)"},{"location":"CHANGELOG/#v0302-2022-07-12","text":"Full Changelog Merged pull requests: Change structure quality scores for materials builder #455 ( munrojm )","title":"v0.30.2 (2022-07-12)"},{"location":"CHANGELOG/#v0301-2022-07-12","text":"Full Changelog Merged pull requests: Fix handling deformation tasks in materials builder #453 ( munrojm )","title":"v0.30.1 (2022-07-12)"},{"location":"CHANGELOG/#v0300-2022-07-12","text":"Full Changelog Merged pull requests: Migrationgraphdoc #437 ( hmlli )","title":"v0.30.0 (2022-07-12)"},{"location":"CHANGELOG/#v0295-2022-07-12","text":"Full Changelog Merged pull requests: Validation fixes #454 ( munrojm )","title":"v0.29.5 (2022-07-12)"},{"location":"CHANGELOG/#v0294-2022-07-08","text":"Full Changelog Merged pull requests: Properly set potcar dir in validation #450 ( munrojm )","title":"v0.29.4 (2022-07-08)"},{"location":"CHANGELOG/#v0293-2022-07-07","text":"Full Changelog Merged pull requests: Fix builder settings #449 ( munrojm )","title":"v0.29.3 (2022-07-07)"},{"location":"CHANGELOG/#v0292-2022-07-07","text":"Full Changelog Merged pull requests: Add mobility utility functions #447 ( acrutt )","title":"v0.29.2 (2022-07-07)"},{"location":"CHANGELOG/#v0291-2022-07-07","text":"Full Changelog Merged pull requests: Materials builder scan changes #448 ( munrojm )","title":"v0.29.1 (2022-07-07)"},{"location":"CHANGELOG/#v0290-2022-07-06","text":"Full Changelog Merged pull requests: Add optic absorption builder #425 ( yang-ruoxi )","title":"v0.29.0 (2022-07-06)"},{"location":"CHANGELOG/#v0284-2022-06-27","text":"Full Changelog Merged pull requests: Ensure electrode groups only pull non-deprecated materials #443 ( munrojm )","title":"v0.28.4 (2022-06-27)"},{"location":"CHANGELOG/#v0283-2022-06-27","text":"Full Changelog Merged pull requests: Add strip_structures to Insertion Electrode Doc and Builder #439 ( acrutt )","title":"v0.28.3 (2022-06-27)"},{"location":"CHANGELOG/#v0282-2022-06-10","text":"Full Changelog Merged pull requests: Add back legacy elasticity model #435 ( munrojm )","title":"v0.28.2 (2022-06-10)"},{"location":"CHANGELOG/#v0281-2022-06-08","text":"Full Changelog Merged pull requests: Better handle formula and element issues #434 ( munrojm )","title":"v0.28.1 (2022-06-08)"},{"location":"CHANGELOG/#v0280-2022-06-07","text":"Full Changelog Merged pull requests: Elasticity doc and builder #326 ( mjwen )","title":"v0.28.0 (2022-06-07)"},{"location":"CHANGELOG/#v0278-2022-06-07","text":"Full Changelog Merged pull requests: Bump maggma #432 ( munrojm )","title":"v0.27.8 (2022-06-07)"},{"location":"CHANGELOG/#v0277-2022-06-06","text":"Full Changelog Merged pull requests: Handle element and formula processing errors #431 ( munrojm )","title":"v0.27.7 (2022-06-06)"},{"location":"CHANGELOG/#v0276-2022-05-31","text":"Full Changelog Merged pull requests: Fix facet memory issue with synthesis aggregation pipeline #430 ( munrojm ) Update the description for chemsys_permutations #424 ( acrutt )","title":"v0.27.6 (2022-05-31)"},{"location":"CHANGELOG/#v0275-2022-05-24","text":"Full Changelog Merged pull requests: Rename molecules_old to molecules_jcesr #423 ( munrojm )","title":"v0.27.5 (2022-05-24)"},{"location":"CHANGELOG/#v0274-2022-05-20","text":"Full Changelog Merged pull requests: Allow tags to be None in validation #419 ( munrojm )","title":"v0.27.4 (2022-05-20)"},{"location":"CHANGELOG/#v0273-2022-05-19","text":"Full Changelog Merged pull requests: Fix tags field in task document #418 ( munrojm )","title":"v0.27.3 (2022-05-19)"},{"location":"CHANGELOG/#v0272-2022-05-13","text":"Full Changelog Merged pull requests: Fix calcs_reversed and output structure #417 ( munrojm )","title":"v0.27.2 (2022-05-13)"},{"location":"CHANGELOG/#v0271-2022-05-13","text":"Full Changelog Merged pull requests: Fix validation projection #416 ( munrojm )","title":"v0.27.1 (2022-05-13)"},{"location":"CHANGELOG/#v0270-2022-05-12","text":"Full Changelog Merged pull requests: Add quantities associated with get_decomp_and_phase_separation_energy #408 ( mkhorton )","title":"v0.27.0 (2022-05-12)"},{"location":"CHANGELOG/#v0263-2022-05-11","text":"Full Changelog Merged pull requests: Take absolute value for magnetic moment validation #415 ( munrojm )","title":"v0.26.3 (2022-05-11)"},{"location":"CHANGELOG/#v0262-2022-05-11","text":"Full Changelog Merged pull requests: Rename old molecules module #414 ( munrojm )","title":"v0.26.2 (2022-05-11)"},{"location":"CHANGELOG/#v0261-2022-05-05","text":"Full Changelog Closed issues: Rename Status enum for molecule tasks #412 Deprecation rule for unphysical magnetic moments #410 Update emmet-builders requirements.txt #329 Merged pull requests: Single atom fix #413 ( espottesmith )","title":"v0.26.1 (2022-05-05)"},{"location":"CHANGELOG/#v0260-2022-05-05","text":"Full Changelog Merged pull requests: Updated deprecation rules, chemenv API endpoint and data, and entries sub-url #411 ( munrojm )","title":"v0.26.0 (2022-05-05)"},{"location":"CHANGELOG/#v0250-2022-05-05","text":"Full Changelog Merged pull requests: [WIP] New data models and builders for molecules #334 ( espottesmith )","title":"v0.25.0 (2022-05-05)"},{"location":"CHANGELOG/#v0245-2022-04-26","text":"Full Changelog Merged pull requests: Switch to using the full MaterialsDoc in the API #404 ( munrojm )","title":"v0.24.5 (2022-04-26)"},{"location":"CHANGELOG/#v0244-2022-04-26","text":"Full Changelog Merged pull requests: Only run doc build after tests pass #401 ( munrojm )","title":"v0.24.4 (2022-04-26)"},{"location":"CHANGELOG/#v0243-2022-04-25","text":"Full Changelog Merged pull requests: Support R2SCAN, SCAN and PBESol tasks in the new build system #236 ( rkingsbury )","title":"v0.24.3 (2022-04-25)"},{"location":"CHANGELOG/#v0242-2022-04-21","text":"Full Changelog Merged pull requests: Bump maggma to fix key endpoint projection issues #398 ( munrojm )","title":"v0.24.2 (2022-04-21)"},{"location":"CHANGELOG/#v0241-2022-04-20","text":"Full Changelog Merged pull requests: Add projection field for charge densities #397 ( munrojm )","title":"v0.24.1 (2022-04-20)"},{"location":"CHANGELOG/#v0240-2022-04-19","text":"Full Changelog Merged pull requests: API S3 object endpoint changes #396 ( munrojm )","title":"v0.24.0 (2022-04-19)"},{"location":"CHANGELOG/#v0230-2022-04-14","text":"Full Changelog Closed issues: Set header to allow for load-testing via continuous integration to bypass CF rate limiting #380 Merged pull requests: Core model and operator improvements, overhaul of pagination params #368 ( munrojm )","title":"v0.23.0 (2022-04-14)"},{"location":"CHANGELOG/#v0220-2022-04-13","text":"Full Changelog Merged pull requests: ChemEnv integration #379 ( JaGeo )","title":"v0.22.0 (2022-04-13)"},{"location":"CHANGELOG/#v02127-2022-04-08","text":"Full Changelog Merged pull requests: Fix material sorting post-process #391 ( munrojm ) Incorrect parameters for hybrid functionals #389 ( nwinner )","title":"v0.21.27 (2022-04-08)"},{"location":"CHANGELOG/#v02126-2022-04-07","text":"Full Changelog Merged pull requests: Add `electronic_steps' to trajectory endpoint and fix structure frame population #390 ( munrojm )","title":"v0.21.26 (2022-04-07)"},{"location":"CHANGELOG/#v02125-2022-04-07","text":"Full Changelog Merged pull requests: Fix structure key handling in trajectory endpoint #388 ( munrojm )","title":"v0.21.25 (2022-04-07)"},{"location":"CHANGELOG/#v02124-2022-04-06","text":"Full Changelog Merged pull requests: Handle trajectory and element dict and value errors #387 ( munrojm )","title":"v0.21.24 (2022-04-06)"},{"location":"CHANGELOG/#v02123-2022-04-06","text":"Full Changelog Merged pull requests: General store post_process bug fix #386 ( munrojm )","title":"v0.21.23 (2022-04-06)"},{"location":"CHANGELOG/#v02122-2022-04-06","text":"Full Changelog Merged pull requests: Enhance post-processing to avoid overwrite issues #385 ( munrojm )","title":"v0.21.22 (2022-04-06)"},{"location":"CHANGELOG/#v02121-2022-03-25","text":"Full Changelog Merged pull requests: Trajectory endpoint fix #382 ( munrojm )","title":"v0.21.21 (2022-03-25)"},{"location":"CHANGELOG/#v02120-2022-02-23","text":"Full Changelog Merged pull requests: Return proper error response in autocomplete endpoint #373 ( munrojm )","title":"v0.21.20 (2022-02-23)"},{"location":"CHANGELOG/#v02119-2022-01-28","text":"Full Changelog Merged pull requests: Fix task doc composition validation issue in API #363 ( munrojm )","title":"v0.21.19 (2022-01-28)"},{"location":"CHANGELOG/#v02118-2022-01-21","text":"Full Changelog Merged pull requests: Battery formula patch + pydantic fix #356 ( munrojm )","title":"v0.21.18 (2022-01-21)"},{"location":"CHANGELOG/#v02117-2022-01-20","text":"Full Changelog Merged pull requests: Electrodes model fix #355 ( munrojm )","title":"v0.21.17 (2022-01-20)"},{"location":"CHANGELOG/#v02116-2022-01-20","text":"Full Changelog Merged pull requests: Remove version req in setup #354 ( munrojm ) Fix setup for workflow #353 ( munrojm )","title":"v0.21.16 (2022-01-20)"},{"location":"CHANGELOG/#v02115-2022-01-19","text":"Full Changelog","title":"v0.21.15 (2022-01-19)"},{"location":"CHANGELOG/#v02114-2022-01-19","text":"Full Changelog Merged pull requests: Fix release workflow #352 ( munrojm )","title":"v0.21.14 (2022-01-19)"},{"location":"CHANGELOG/#v02113-2022-01-19","text":"Full Changelog Merged pull requests: Revert nesting _verison.py #351 ( munrojm )","title":"v0.21.13 (2022-01-19)"},{"location":"CHANGELOG/#v02112-2022-01-19","text":"Full Changelog Merged pull requests: Revert to get_distribution in init #349 ( munrojm )","title":"v0.21.12 (2022-01-19)"},{"location":"CHANGELOG/#v02110-2022-01-19","text":"Full Changelog","title":"v0.21.10 (2022-01-19)"},{"location":"CHANGELOG/#v02111-2022-01-19","text":"Full Changelog Merged pull requests: Move _version.py further into package to fix import issues #348 ( munrojm )","title":"v0.21.11 (2022-01-19)"},{"location":"CHANGELOG/#v0219-2022-01-19","text":"Full Changelog Merged pull requests: Git stash added to docs step #347 ( munrojm )","title":"v0.21.9 (2022-01-19)"},{"location":"CHANGELOG/#v0217-2022-01-19","text":"Full Changelog","title":"v0.21.7 (2022-01-19)"},{"location":"CHANGELOG/#v0218-2022-01-19","text":"Full Changelog Merged pull requests: Git pull added to docs #346 ( munrojm )","title":"v0.21.8 (2022-01-19)"},{"location":"CHANGELOG/#v0216-2022-01-19","text":"Full Changelog Merged pull requests: Fix git pull command in workflow #345 ( munrojm )","title":"v0.21.6 (2022-01-19)"},{"location":"CHANGELOG/#v0215-2022-01-19","text":"Full Changelog Merged pull requests: Git pull to sync between namespace steps #344 ( munrojm )","title":"v0.21.5 (2022-01-19)"},{"location":"CHANGELOG/#v0214-2022-01-19","text":"Full Changelog Merged pull requests: Version file generation pushed into namespace packages #343 ( munrojm )","title":"v0.21.4 (2022-01-19)"},{"location":"CHANGELOG/#v0213-2022-01-15","text":"Full Changelog Merged pull requests: Revert version update to release workflow with conditionals #340 ( munrojm )","title":"v0.21.3 (2022-01-15)"},{"location":"CHANGELOG/#v0212-2022-01-15","text":"Full Changelog Merged pull requests: Alter commit message in actions #339 ( munrojm ) Fix version push in actions #338 ( munrojm )","title":"v0.21.2 (2022-01-15)"},{"location":"CHANGELOG/#v0211-2022-01-15","text":"Full Changelog Merged pull requests: Alter how version is determined #337 ( munrojm )","title":"v0.21.1 (2022-01-15)"},{"location":"CHANGELOG/#v0210-2022-01-13","text":"Full Changelog Merged pull requests: Chemsys, electrode, provenance, and robocrys changes #336 ( munrojm ) Allow for parsing of material docs without GGA/GGA+U (i.e. without corrections) #335 ( arosen93 )","title":"v0.21.0 (2022-01-13)"},{"location":"CHANGELOG/#v0203-2022-01-07","text":"Full Changelog Merged pull requests: Substrates patch #332 ( munrojm )","title":"v0.20.3 (2022-01-07)"},{"location":"CHANGELOG/#v0202-2022-01-07","text":"Full Changelog Merged pull requests: Bump min maggma version #330 ( munrojm )","title":"v0.20.2 (2022-01-07)"},{"location":"CHANGELOG/#v0201-2022-01-06","text":"Full Changelog Merged pull requests: Add dockerfile for emmet api #328 ( munrojm )","title":"v0.20.1 (2022-01-06)"},{"location":"CHANGELOG/#v0200-2022-01-06","text":"Full Changelog Closed issues: Elastic builder #245 Merged pull requests: Emmet API package #327 ( munrojm )","title":"v0.20.0 (2022-01-06)"},{"location":"CHANGELOG/#v0191-2021-12-21","text":"Full Changelog Merged pull requests: Electrode host structure bug fix #323 ( munrojm )","title":"v0.19.1 (2021-12-21)"},{"location":"CHANGELOG/#v0190-2021-12-20","text":"Full Changelog Merged pull requests: Electrode builder updates #322 ( munrojm )","title":"v0.19.0 (2021-12-20)"},{"location":"CHANGELOG/#v0180-2021-11-24","text":"Full Changelog Merged pull requests: General builder updates #317 ( munrojm )","title":"v0.18.0 (2021-11-24)"},{"location":"CHANGELOG/#v0170-2021-11-17","text":"Full Changelog Merged pull requests: Update emmet meta #313 ( munrojm )","title":"v0.17.0 (2021-11-17)"},{"location":"CHANGELOG/#v0160-2021-11-13","text":"Full Changelog Merged pull requests: Initial commit of similarity builder #310 ( munrojm )","title":"v0.16.0 (2021-11-13)"},{"location":"CHANGELOG/#v01516-2021-11-12","text":"Full Changelog Merged pull requests: Fix default phase diagram value #309 ( munrojm )","title":"v0.15.16 (2021-11-12)"},{"location":"CHANGELOG/#v01515-2021-11-12","text":"Full Changelog Merged pull requests: Remove store query for phase diagram data #308 ( munrojm )","title":"v0.15.15 (2021-11-12)"},{"location":"CHANGELOG/#v01514-2021-11-11","text":"Full Changelog Merged pull requests: Add element number cap to phase diagram generation in thermo #307 ( munrojm )","title":"v0.15.14 (2021-11-11)"},{"location":"CHANGELOG/#v01513-2021-11-09","text":"Full Changelog Merged pull requests: Remove summary sub docs to fix magnetism and polar data #306 ( munrojm )","title":"v0.15.13 (2021-11-09)"},{"location":"CHANGELOG/#v01512-2021-11-08","text":"Full Changelog Merged pull requests: Include charge_density in summary has_props #305 ( munrojm )","title":"v0.15.12 (2021-11-08)"},{"location":"CHANGELOG/#v01511-2021-11-02","text":"Full Changelog Merged pull requests: Final polar builder updates #303 ( munrojm ) Remove chunking methods from test coverage for materials and thermo #302 ( munrojm )","title":"v0.15.11 (2021-11-02)"},{"location":"CHANGELOG/#v01510-2021-11-01","text":"Full Changelog Merged pull requests: Patch fix correct tensor variable in dielectric #301 ( munrojm )","title":"v0.15.10 (2021-11-01)"},{"location":"CHANGELOG/#v0159-2021-11-01","text":"Full Changelog Merged pull requests: Ensure DFPT tasks in polar builders #300 ( munrojm )","title":"v0.15.9 (2021-11-01)"},{"location":"CHANGELOG/#v0158-2021-10-31","text":"Full Changelog Merged pull requests: Remove output structure from polar builders #298 ( munrojm )","title":"v0.15.8 (2021-10-31)"},{"location":"CHANGELOG/#v0157-2021-10-29","text":"Full Changelog Merged pull requests: Convert structure inside bonds builder #297 ( munrojm )","title":"v0.15.7 (2021-10-29)"},{"location":"CHANGELOG/#v0156-2021-10-29","text":"Full Changelog Merged pull requests: Reference proper structure in polar builders #296 ( munrojm )","title":"v0.15.6 (2021-10-29)"},{"location":"CHANGELOG/#v0155-2021-10-28","text":"Full Changelog Merged pull requests: Fix piezo model #295 ( munrojm )","title":"v0.15.5 (2021-10-28)"},{"location":"CHANGELOG/#v0154-2021-10-27","text":"Full Changelog Merged pull requests: Fix grouper bug #294 ( munrojm )","title":"v0.15.4 (2021-10-27)"},{"location":"CHANGELOG/#v0153-2021-10-27","text":"Full Changelog Merged pull requests: Structure grouper chemsys chunk fix #292 ( munrojm )","title":"v0.15.3 (2021-10-27)"},{"location":"CHANGELOG/#v0152-2021-10-25","text":"Full Changelog Merged pull requests: Chunk with chemsys in structure group builder #289 ( munrojm )","title":"v0.15.2 (2021-10-25)"},{"location":"CHANGELOG/#v0151-2021-10-25","text":"Full Changelog Merged pull requests: Fix electrode chunking #288 ( munrojm )","title":"v0.15.1 (2021-10-25)"},{"location":"CHANGELOG/#v0150-2021-10-22","text":"Full Changelog Merged pull requests: Magnetism builder updates #286 ( munrojm )","title":"v0.15.0 (2021-10-22)"},{"location":"CHANGELOG/#v0146-2021-10-21","text":"Full Changelog Merged pull requests: Builder chunking fixes #287 ( munrojm )","title":"v0.14.6 (2021-10-21)"},{"location":"CHANGELOG/#v0145-2021-10-15","text":"Full Changelog Merged pull requests: Optimize phase diagram building in the thermo builder #283 ( munrojm )","title":"v0.14.5 (2021-10-15)"},{"location":"CHANGELOG/#v0144-2021-10-14","text":"Full Changelog Merged pull requests: thermo builder bugs #282 ( acrutt )","title":"v0.14.4 (2021-10-14)"},{"location":"CHANGELOG/#v0143-2021-10-13","text":"Full Changelog Merged pull requests: ThermoDoc.from_entries() energy fix #281 ( acrutt )","title":"v0.14.3 (2021-10-13)"},{"location":"CHANGELOG/#v0142-2021-10-12","text":"Full Changelog Merged pull requests: ComputedStructureEntry type consistency #279 ( acrutt )","title":"v0.14.2 (2021-10-12)"},{"location":"CHANGELOG/#v0141-2021-10-12","text":"Full Changelog Merged pull requests: Fix phase diagram ensure index #280 ( munrojm )","title":"v0.14.1 (2021-10-12)"},{"location":"CHANGELOG/#v0140-2021-10-11","text":"Full Changelog Merged pull requests: Update dielectric, piezoelectric and thermo builders #278 ( munrojm )","title":"v0.14.0 (2021-10-11)"},{"location":"CHANGELOG/#v0133-2021-09-28","text":"Full Changelog Merged pull requests: Summary additions and fixes #276 ( munrojm )","title":"v0.13.3 (2021-09-28)"},{"location":"CHANGELOG/#v0132-2021-09-25","text":"Full Changelog Merged pull requests: Elements to chemsys in validation check #274 ( munrojm )","title":"v0.13.2 (2021-09-25)"},{"location":"CHANGELOG/#v0131-2021-09-24","text":"Full Changelog Merged pull requests: Small builder changes #273 ( munrojm )","title":"v0.13.1 (2021-09-24)"},{"location":"CHANGELOG/#v0130-2021-09-23","text":"Full Changelog Merged pull requests: Builder bug fixes #272 ( munrojm )","title":"v0.13.0 (2021-09-23)"},{"location":"CHANGELOG/#v0128-2021-09-15","text":"Full Changelog","title":"v0.12.8 (2021-09-15)"},{"location":"CHANGELOG/#v0127-2021-09-15","text":"Full Changelog Merged pull requests: Remove phase diagram from thermo doc and builder #270 ( munrojm )","title":"v0.12.7 (2021-09-15)"},{"location":"CHANGELOG/#v0126-2021-09-14","text":"Full Changelog Merged pull requests: Materials and thermo builder fixes #269 ( munrojm )","title":"v0.12.6 (2021-09-14)"},{"location":"CHANGELOG/#v0125-2021-09-09","text":"Full Changelog Merged pull requests: Chunking bug fix #265 ( munrojm )","title":"v0.12.5 (2021-09-09)"},{"location":"CHANGELOG/#v0124-2021-09-09","text":"Full Changelog Merged pull requests: Fix pre-chunking for materials and thermo builder #264 ( munrojm )","title":"v0.12.4 (2021-09-09)"},{"location":"CHANGELOG/#v0123-2021-09-09","text":"Full Changelog Merged pull requests: Fix material builder #263 ( munrojm )","title":"v0.12.3 (2021-09-09)"},{"location":"CHANGELOG/#v0122-2021-09-02","text":"Full Changelog Merged pull requests: Validation builder U fix #257 ( munrojm )","title":"v0.12.2 (2021-09-02)"},{"location":"CHANGELOG/#v0121-2021-09-02","text":"Full Changelog Merged pull requests: Provenance to summary #256 ( munrojm )","title":"v0.12.1 (2021-09-02)"},{"location":"CHANGELOG/#v0120-2021-09-02","text":"Full Changelog Merged pull requests: Provenance overhaul #255 ( munrojm )","title":"v0.12.0 (2021-09-02)"},{"location":"CHANGELOG/#v0110-2021-08-26","text":"Full Changelog Merged pull requests: Builder updates for legacy data parity #249 ( munrojm )","title":"v0.11.0 (2021-08-26)"},{"location":"CHANGELOG/#v0100-2021-08-19","text":"Full Changelog Merged pull requests: Deprecation data added to PropertyDoc #247 ( munrojm )","title":"v0.10.0 (2021-08-19)"},{"location":"CHANGELOG/#v093-2021-08-05","text":"Full Changelog Merged pull requests: Fix property doc names #241 ( shyamd )","title":"v0.9.3 (2021-08-05)"},{"location":"CHANGELOG/#v092-2021-08-05","text":"Full Changelog Closed issues: feature: build data in all models #202 Merged pull requests: fix bugs in MPID #240 ( rkingsbury )","title":"v0.9.2 (2021-08-05)"},{"location":"CHANGELOG/#v091-2021-07-26","text":"Full Changelog Merged pull requests: Revert structure back to using computed structure #239 ( shyamd )","title":"v0.9.1 (2021-07-26)"},{"location":"CHANGELOG/#v090-2021-07-23","text":"Full Changelog Closed issues: Fix and standardize settings context var #237 Build data in document model #232 Thoughts on having StructureNL instead of Structure in canonical materials structure field? #97 Merged pull requests: New EmmetBaseModel #235 ( shyamd ) Substrates #231 ( shyamd ) Optimade Materials Doc #230 ( shyamd )","title":"v0.9.0 (2021-07-23)"},{"location":"CHANGELOG/#v083-2021-07-20","text":"Full Changelog Fixed bugs: Oxidation state composition fields not serialized properly #216 Closed issues: Feature Request: Robocrystallographer #208 Rotate structure to standard convention #111 Returned docs too large for common API queries (third-order elasticity) #76 Merged pull requests: Better Provenance Management #228 ( shyamd )","title":"v0.8.3 (2021-07-20)"},{"location":"CHANGELOG/#v082-2021-07-16","text":"Full Changelog Merged pull requests: Summary field bug fix #226 ( munrojm )","title":"v0.8.2 (2021-07-16)"},{"location":"CHANGELOG/#v081-2021-07-15","text":"Full Changelog Merged pull requests: Rename summary stats model #225 ( munrojm )","title":"v0.8.1 (2021-07-15)"},{"location":"CHANGELOG/#v080-2021-07-15","text":"Full Changelog Merged pull requests: Electronic structure and search builder updates #221 ( munrojm )","title":"v0.8.0 (2021-07-15)"},{"location":"CHANGELOG/#v072-2021-07-15","text":"Full Changelog Merged pull requests: Fix Deprecated Materials Speed #224 ( shyamd )","title":"v0.7.2 (2021-07-15)"},{"location":"CHANGELOG/#v071-2021-07-13","text":"Full Changelog","title":"v0.7.1 (2021-07-13)"},{"location":"CHANGELOG/#v070-2021-07-13","text":"Full Changelog Merged pull requests: Robocrystallographer document #222 ( shyamd )","title":"v0.7.0 (2021-07-13)"},{"location":"CHANGELOG/#v060-2021-07-12","text":"Full Changelog Merged pull requests: Add Deprecated Materials to MaterialsDoc construction #220 ( shyamd ) Fix provenance #219 ( shyamd )","title":"v0.6.0 (2021-07-12)"},{"location":"CHANGELOG/#v050-2021-07-02","text":"Full Changelog Merged pull requests: Fix Validation #215 ( shyamd )","title":"v0.5.0 (2021-07-02)"},{"location":"CHANGELOG/#v041-2021-06-27","text":"Full Changelog Merged pull requests: Fix oxidation doc composition #217 ( shyamd )","title":"v0.4.1 (2021-06-27)"},{"location":"CHANGELOG/#v040-2021-06-24","text":"Full Changelog Merged pull requests: Add R2SCAN to run_types #214 ( shyamd )","title":"v0.4.0 (2021-06-24)"},{"location":"CHANGELOG/#v036-2021-06-24","text":"Full Changelog Merged pull requests: Fix projection for vasp run_type determination #213 ( shyamd )","title":"v0.3.6 (2021-06-24)"},{"location":"CHANGELOG/#v035-2021-06-24","text":"Full Changelog Merged pull requests: Fix run_type in validation #212 ( shyamd )","title":"v0.3.5 (2021-06-24)"},{"location":"CHANGELOG/#v034-2021-06-23","text":"Full Changelog Merged pull requests: Bug: Reference the last calculation to determine run_type #211 ( shyamd )","title":"v0.3.4 (2021-06-23)"},{"location":"CHANGELOG/#v033-2021-06-23","text":"Full Changelog Merged pull requests: Remove bson package requirement #209 ( shyamd )","title":"v0.3.3 (2021-06-23)"},{"location":"CHANGELOG/#v032-2021-06-21","text":"Full Changelog Merged pull requests: Electronic Structure model and builder fixes #206 ( munrojm )","title":"v0.3.2 (2021-06-21)"},{"location":"CHANGELOG/#v031-2021-06-21","text":"Full Changelog Merged pull requests: Use deprecated tasks in Materials Builder #207 ( shyamd )","title":"v0.3.1 (2021-06-21)"},{"location":"CHANGELOG/#v030-2021-06-16","text":"Full Changelog Merged pull requests: Release Emmet Builders #205 ( shyamd )","title":"v0.3.0 (2021-06-16)"},{"location":"CHANGELOG/#v024-2021-06-14","text":"Full Changelog Merged pull requests: Revert materials finding to old pipeline behavior #203 ( shyamd )","title":"v0.2.4 (2021-06-14)"},{"location":"CHANGELOG/#v023-2021-06-07","text":"Full Changelog Merged pull requests: Fix oxidation document #201 ( shyamd )","title":"v0.2.3 (2021-06-07)"},{"location":"CHANGELOG/#v022-2021-06-04","text":"Full Changelog","title":"v0.2.2 (2021-06-04)"},{"location":"CHANGELOG/#v021-2021-06-03","text":"Full Changelog Merged pull requests: Reconcile changes on updates branch #199 ( shyamd ) Oxidation State Document #198 ( shyamd ) Move XAS Logic into document and clean up builder #197 ( shyamd ) Electronic structure and search components #189 ( munrojm )","title":"v0.2.1 (2021-06-03)"},{"location":"CHANGELOG/#v020-2021-05-10","text":"Full Changelog Closed issues: Bug: set's get serialized into set() rather than a list #183 task_type is moved to vasp/calc_type #121 Merged pull requests: various fixes to structure grouper an electrode documents and builders #178 ( jmmshn ) Updated materials and thermo builder #177 ( jmmshn ) Provenance Builder #176 ( shyamd ) relaxed enforced type of orig_input #175 ( jmmshn ) Fix serialization and update validation #174 ( shyamd ) Working Thermo Builder #170 ( jmmshn ) Add SCF gradient and Manual deprecation to VASP validation #169 ( shyamd ) Create MPID Type #167 ( shyamd ) Remove stubs in favor of monty pydantic compatability #165 ( shyamd ) made structure grouper work with material_ids #163 ( jmmshn ) minor changes to get material builder working on non-production databases. #162 ( jmmshn ) Electrode Doc #149 ( jmmshn ) Structure Group Docs and Builder #148 ( jmmshn ) Generate static run-types for IDEs #141 ( shyamd ) Added CrossRef builder #133 ( jmmshn ) Sanitize Enums #132 ( utf ) Use lattice model #131 ( utf ) cli: restoring tasks (bugfixes) #119 ( tschaume ) Emmet-Core Docs #117 ( shyamd ) Initial Documentation Structure #116 ( shyamd )","title":"v0.2.0 (2021-05-10)"},{"location":"CHANGELOG/#v011-alpha-2020-04-19","text":"Full Changelog","title":"v0.1.1-alpha (2020-04-19)"},{"location":"CHANGELOG/#v01-alpha-2020-04-19","text":"Full Changelog Closed issues: Conflicts in electrodes.py #108 Band gaps being reported differently from those described by mapidoc / the old builders #62 KeyError when running lu_field with a store already containing data #45 VaspDrone for emmet? #40 Merged pull requests: fixes for electrode builder #113 ( jmmshn ) Updates for the latest DB release #110 ( shyamd ) Working insertion electrodes builder #109 ( jmmshn ) Production updates for September 2019 #107 ( shyamd ) Update ICSD drone #105 ( kmu ) Change magnetism builder to build from tasks #104 ( mkhorton ) CLI: primitive structures, zip support, SNLs #101 ( tschaume ) Added StructurePredictionBuilder #98 ( mattmcdermott ) WIP: Initial creation of defects emmet builder #95 ( dbroberg ) WIP: Acceptance tests for deprecation guarding etc. #94 ( dwinston ) missing and (how did this work?) #93 ( tschaume ) Fix a bug in bond_valence #92 ( kmu ) bug fix #90 ( jmmshn ) Central repository for global variables #88 ( mkhorton ) WIP March Production Updates #87 ( shyamd ) Fixed sandbox bug and cleaned up #84 ( jmmshn ) Website Updates #82 ( shyamd ) Update to electrode builder to match the data required by the website builder #81 ( jmmshn ) Robocrystallographer audio builder #79 ( dwinston ) Build structure visualization JSON #78 ( mkhorton ) Add robocrys version to builder doc #75 ( utf ) Add robocrystallographer builder #74 ( utf ) [WIP] MPComplete status #73 ( dwinston ) Production Updates #72 ( shyamd ) fix: snl history is a list #70 ( dwinston ) Maggma update #69 ( shyamd ) [WIP] Update magnetic grouping #67 ( mkhorton ) Battery builder (work in progress) #66 ( jmmshn ) Production Updates #65 ( shyamd ) [WIP] Updates to magnetism, bond, mp_website builders, new bond_valence, mp_website_digest builders #64 ( mkhorton ) mp website update for propnet and toecs #63 ( montoyjh ) big elastic PR #61 ( montoyjh ) Added meta data & unit tests #60 ( nisse3000 ) Added composition descritpors for similarity toolbox #59 ( nisse3000 ) Fix 'magnestism' typo #58 ( mkhorton ) Removed min and max statistics from structure fingerprint #57 ( nisse3000 ) Updated site-descriptor calculation to reflect best settings. #56 ( nisse3000 ) [WIP] x-ray absorption spectra builder updates #55 ( dwinston ) Requested site-descriptor changes #53 ( nisse3000 ) Install openbabel in test env #52 ( dwinston ) More Updates for MP Website #49 ( shyamd ) Avoid hardcoding local settings path on serialization #48 ( dwinston ) Added BoltztrapDosBuilder class #42 ( fraricci ) [WIP] Command Line Interface #41 ( tschaume )","title":"v0.1-alpha (2020-04-19)"},{"location":"CHANGELOG/#v201867-2018-06-07","text":"Full Changelog","title":"v2018.6.7 (2018-06-07)"},{"location":"CHANGELOG/#v201866-2018-06-06","text":"Full Changelog Merged pull requests: Updates #47 ( shyamd ) Fix diffraction builder. Add test for fixed method. #46 ( dwinston ) Replace TopologyBuilder with BondBuilder #44 ( mkhorton ) Copybuilder additions #43 ( montoyjh ) Massive amounts of refactoring in main builders #39 ( shyamd ) Adaptions to new pymatgen version and requiring most recent pymatgen version #37 ( nisse3000 ) Fixes a few issues in wf builder and elastic builder #36 ( montoyjh ) Copybuilder bug - tqdm doesn't play nicely with next() #35 ( montoyjh ) Add tests for copybuilder. Was using old store attr lu_key . #34 ( dwinston ) README: editable install #33 ( tschaume ) Property workflow builder #32 ( montoyjh )","title":"v2018.6.6 (2018-06-06)"},{"location":"CHANGELOG/#v201842-2018-04-02","text":"Full Changelog Closed issues: A generalized warning generator for task documents? #26 Merged pull requests: Changed site-descriptor data structure & adapted structure similarity builder accordingly #31 ( nisse3000 ) Massive reorganization #28 ( shyamd ) Corrected setup.py #27 ( nisse3000 )","title":"v2018.4.2 (2018-04-02)"},{"location":"CHANGELOG/#v201839-2018-03-09","text":"Full Changelog Closed issues: SurfacePropertiesBuilder #23 Merged pull requests: Massive changeset for Production #25 ( shyamd ) Restructured site-descriptor storage #24 ( nisse3000 ) Added a site-descriptor builder #22 ( nisse3000 ) Builder updates (topology) #21 ( mkhorton ) Compatibility and elastic builders #20 ( montoyjh ) Fix substrates builder #18 ( dwinston ) abinit phonon builder #16 ( gpetretto )","title":"v2018.3.9 (2018-03-09)"},{"location":"CHANGELOG/#v201811-2017-12-16","text":"Full Changelog","title":"v2018.1.1 (2017-12-16)"},{"location":"CHANGELOG/#v2017118-2017-11-07","text":"Full Changelog Closed issues: PyPi package #2 Merged pull requests: Readme update #15 ( mkhorton ) Initial topology builder #10 ( mkhorton ) Small update to README #9 ( mkhorton ) Small README update #8 ( mkhorton ) ICSD drone #7 ( JPalakapilly ) Fix sample script in README #6 ( mkhorton ) Minor doc update #5 ( mkhorton ) Initial commit for some documentation (in progress) #4 ( mkhorton ) Materials builder #3 ( shyamd ) Task tagger #1 ( shyamd ) * This Changelog was automatically generated by github_changelog_generator","title":"v2017.11.8 (2017-11-07)"},{"location":"core/","text":"Emmet-Core \u00b6 The core module defines the data models for the Materials API (MAPI): CrystalSystem ( ValueEnum ) \u00b6 The crystal system of the lattice Source code in core/symmetry.py class CrystalSystem ( ValueEnum ): \"\"\" The crystal system of the lattice \"\"\" tri = \"Triclinic\" mono = \"Monoclinic\" ortho = \"Orthorhombic\" tet = \"Tetragonal\" trig = \"Trigonal\" hex_ = \"Hexagonal\" cubic = \"Cubic\" PointGroupData ( BaseModel ) pydantic-model \u00b6 Defines symmetry for a molecule document Source code in core/symmetry.py class PointGroupData ( BaseModel ): \"\"\" Defines symmetry for a molecule document \"\"\" point_group : str = Field ( None , title = \"Point Group Symbol\" , description = \"The point group for the lattice\" ) rotation_number : float = Field ( None , title = \"Rotational Symmetry Number\" , description = \"Rotational symmetry number for the molecule\" , ) linear : bool = Field ( None , title = \"Molecule Linearity\" , description = \"Is the molecule linear?\" ) tolerance : float = Field ( None , title = \"Point Group Analyzer Tolerance\" , description = \"Distance tolerance to consider sites as symmetrically equivalent.\" , ) eigen_tolerance : float = Field ( None , title = \"Interia Tensor Eigenvalue Tolerance\" , description = \"Tolerance to compare eigen values of the inertia tensor.\" , ) matrix_tolerance : float = Field ( None , title = \"Symmetry Operation Matrix Element Tolerance\" , description = \"Tolerance used to generate the full set of symmetry operations of the point group.\" , ) @classmethod def from_molecule ( cls , molecule : Molecule ) -> \"PointGroupData\" : tol = SETTINGS . PGATOL eigentol = SETTINGS . PGAEIGENTOL matrixtol = SETTINGS . PGAMATRIXTOL pga = PointGroupAnalyzer ( molecule , tolerance = tol , eigen_tolerance = eigentol , matrix_tolerance = matrixtol , ) symmetry : Dict [ str , Any ] = { \"tolerance\" : tol , \"eigen_tolerance\" : eigentol , \"matrix_tolerance\" : matrixtol , \"point_group\" : pga . sch_symbol , } rotational_symmetry_numbers = { 1.0 : [ \"C1\" , \"Cs\" , \"Ci\" , \"C*v\" , \"S2\" ], 2.0 : [ \"C2\" , \"C2h\" , \"C2v\" , \"S4\" , \"D*h\" ], 3.0 : [ \"C3\" , \"C3h\" , \"C3v\" , \"S6\" ], 4.0 : [ \"C4v\" , \"D4h\" , \"D4d\" , \"D2\" , \"D2h\" , \"D2d\" ], 5.0 : [ \"C5v\" , \"Ih\" ], 6.0 : [ \"D3\" , \"D3h\" , \"D3d\" ], 10.0 : [ \"D5h\" , \"D5d\" ], 12.0 : [ \"T\" , \"Td\" , \"Th\" , \"D6h\" ], 14.0 : [ \"D7h\" ], 16.0 : [ \"D8h\" ], 24.0 : [ \"Oh\" ], float ( \"inf\" ): [ \"Kh\" ], } r = 1.0 for rot_num , point_groups in rotational_symmetry_numbers . items (): if symmetry [ \"point_group\" ] in point_groups : r = rot_num break if symmetry [ \"point_group\" ] in [ \"C*v\" , \"D*h\" ]: linear = True else : linear = False symmetry [ \"rotation_number\" ] = float ( r ) symmetry [ \"linear\" ] = linear return PointGroupData ( ** symmetry ) eigen_tolerance : float pydantic-field \u00b6 Tolerance to compare eigen values of the inertia tensor. linear : bool pydantic-field \u00b6 Is the molecule linear? matrix_tolerance : float pydantic-field \u00b6 Tolerance used to generate the full set of symmetry operations of the point group. point_group : str pydantic-field \u00b6 The point group for the lattice rotation_number : float pydantic-field \u00b6 Rotational symmetry number for the molecule tolerance : float pydantic-field \u00b6 Distance tolerance to consider sites as symmetrically equivalent. SymmetryData ( BaseModel ) pydantic-model \u00b6 Defines a symmetry data set for materials documents Source code in core/symmetry.py class SymmetryData ( BaseModel ): \"\"\" Defines a symmetry data set for materials documents \"\"\" crystal_system : CrystalSystem = Field ( None , title = \"Crystal System\" , description = \"The crystal system for this lattice.\" ) symbol : str = Field ( None , title = \"Space Group Symbol\" , description = \"The spacegroup symbol for the lattice.\" , ) number : int = Field ( None , title = \"Space Group Number\" , description = \"The spacegroup number for the lattice.\" , ) point_group : str = Field ( None , title = \"Point Group Symbol\" , description = \"The point group for the lattice.\" ) symprec : float = Field ( None , title = \"Symmetry Finding Precision\" , description = \"The precision given to spglib to determine the symmetry of this lattice.\" , ) version : str = Field ( None , title = \"SPGLib version\" ) @classmethod def from_structure ( cls , structure : Structure ) -> \"SymmetryData\" : symprec = SETTINGS . SYMPREC sg = SpacegroupAnalyzer ( structure , symprec = symprec ) symmetry : Dict [ str , Any ] = { \"symprec\" : symprec } if not sg . get_symmetry_dataset (): sg = SpacegroupAnalyzer ( structure , 1e-3 , 1 ) symmetry [ \"symprec\" ] = 1e-3 symmetry . update ( { \"source\" : \"spglib\" , \"symbol\" : sg . get_space_group_symbol (), \"number\" : sg . get_space_group_number (), \"point_group\" : sg . get_point_group_symbol (), \"crystal_system\" : CrystalSystem ( sg . get_crystal_system () . title ()), \"hall\" : sg . get_hall (), \"version\" : spglib . __version__ , } ) return SymmetryData ( ** symmetry ) crystal_system : CrystalSystem pydantic-field \u00b6 The crystal system for this lattice. number : int pydantic-field \u00b6 The spacegroup number for the lattice. point_group : str pydantic-field \u00b6 The point group for the lattice. symbol : str pydantic-field \u00b6 The spacegroup symbol for the lattice. symprec : float pydantic-field \u00b6 The precision given to spglib to determine the symmetry of this lattice. Core definition of Structure metadata MoleculeMetadata ( EmmetBaseModel ) pydantic-model \u00b6 Mix-in class for molecule metadata Source code in core/structure.py class MoleculeMetadata ( EmmetBaseModel ): \"\"\" Mix-in class for molecule metadata \"\"\" charge : float = Field ( None , description = \"Charge of the molecule\" ) spin_multiplicity : int = Field ( None , description = \"Spin multiplicity of the molecule\" ) natoms : int = Field ( None , description = \"Total number of atoms in the molecule\" ) elements : List [ Element ] = Field ( None , description = \"List of elements in the molecule\" ) nelements : int = Field ( None , title = \"Number of Elements\" ) composition : Composition = Field ( None , description = \"Full composition for the molecule\" ) formula_alphabetical : str = Field ( None , title = \"Alphabetical Formula\" , description = \"Alphabetical molecular formula\" , ) chemsys : str = Field ( None , title = \"Chemical System\" , description = \"dash-delimited string of elements in the molecule\" , ) symmetry : PointGroupData = Field ( None , description = \"Symmetry data for this molecule\" ) @classmethod def from_molecule ( cls : Type [ S ], meta_molecule : Molecule , fields : Optional [ List [ str ]] = None , ** kwargs ) -> T : fields = ( [ \"charge\" , \"spin_multiplicity\" , \"natoms\" , \"elements\" , \"nelements\" , \"composition\" , \"formula_alphabetical\" , \"chemsys\" , \"symmetry\" , ] if fields is None else fields ) comp = meta_molecule . composition elsyms = sorted ( set ([ e . symbol for e in comp . elements ])) symmetry = PointGroupData . from_molecule ( meta_molecule ) data = { \"charge\" : meta_molecule . charge , \"spin_multiplicity\" : meta_molecule . spin_multiplicity , \"nsites\" : len ( meta_molecule ), \"elements\" : elsyms , \"nelements\" : len ( elsyms ), \"composition\" : comp , \"formula_alphabetical\" : comp . alphabetical_formula , \"chemsys\" : \"-\" . join ( elsyms ), \"symmetry\" : symmetry , } return cls ( ** { k : v for k , v in data . items () if k in fields }, ** kwargs ) charge : float pydantic-field \u00b6 Charge of the molecule chemsys : str pydantic-field \u00b6 dash-delimited string of elements in the molecule composition : Composition pydantic-field \u00b6 Full composition for the molecule elements : List [ pymatgen . core . periodic_table . Element ] pydantic-field \u00b6 List of elements in the molecule formula_alphabetical : str pydantic-field \u00b6 Alphabetical molecular formula natoms : int pydantic-field \u00b6 Total number of atoms in the molecule spin_multiplicity : int pydantic-field \u00b6 Spin multiplicity of the molecule symmetry : PointGroupData pydantic-field \u00b6 Symmetry data for this molecule StructureMetadata ( EmmetBaseModel ) pydantic-model \u00b6 Mix-in class for structure metadata Source code in core/structure.py class StructureMetadata ( EmmetBaseModel ): \"\"\" Mix-in class for structure metadata \"\"\" # Structure metadata nsites : int = Field ( None , description = \"Total number of sites in the structure.\" ) elements : List [ Element ] = Field ( None , description = \"List of elements in the material.\" ) nelements : int = Field ( None , description = \"Number of elements.\" ) composition : Composition = Field ( None , description = \"Full composition for the material.\" ) composition_reduced : Composition = Field ( None , title = \"Reduced Composition\" , description = \"Simplified representation of the composition.\" , ) formula_pretty : str = Field ( None , title = \"Pretty Formula\" , description = \"Cleaned representation of the formula.\" , ) formula_anonymous : str = Field ( None , title = \"Anonymous Formula\" , description = \"Anonymized representation of the formula.\" , ) chemsys : str = Field ( None , title = \"Chemical System\" , description = \"dash-delimited string of elements in the material.\" , ) volume : float = Field ( None , title = \"Volume\" , description = \"Total volume for this structure in Angstroms^3.\" , ) density : float = Field ( None , title = \"Density\" , description = \"Density in grams per cm^3.\" ) density_atomic : float = Field ( None , title = \"Packing Density\" , description = \"The atomic packing density in atoms per cm^3.\" , ) symmetry : SymmetryData = Field ( None , description = \"Symmetry data for this material.\" ) @classmethod def from_composition ( cls : Type [ T ], composition : Composition , fields : Optional [ List [ str ]] = None , ** kwargs , ) -> T : fields = ( [ \"elements\" , \"nelements\" , \"composition\" , \"composition_reduced\" , \"formula_pretty\" , \"formula_anonymous\" , \"chemsys\" , ] if fields is None else fields ) composition = composition . remove_charges () elsyms = sorted ( set ([ e . symbol for e in composition . elements ])) data = { \"elements\" : elsyms , \"nelements\" : len ( elsyms ), \"composition\" : composition , \"composition_reduced\" : composition . reduced_composition . remove_charges (), \"formula_pretty\" : composition . reduced_formula , \"formula_anonymous\" : composition . anonymized_formula , \"chemsys\" : \"-\" . join ( elsyms ), } return cls ( ** { k : v for k , v in data . items () if k in fields }, ** kwargs ) @classmethod def from_structure ( cls : Type [ T ], meta_structure : Structure , fields : Optional [ List [ str ]] = None , ** kwargs , ) -> T : fields = ( [ \"nsites\" , \"elements\" , \"nelements\" , \"composition\" , \"composition_reduced\" , \"formula_pretty\" , \"formula_anonymous\" , \"chemsys\" , \"volume\" , \"density\" , \"density_atomic\" , \"symmetry\" , ] if fields is None else fields ) comp = meta_structure . composition . remove_charges () elsyms = sorted ( set ([ e . symbol for e in comp . elements ])) symmetry = SymmetryData . from_structure ( meta_structure ) data = { \"nsites\" : meta_structure . num_sites , \"elements\" : elsyms , \"nelements\" : len ( elsyms ), \"composition\" : comp , \"composition_reduced\" : comp . reduced_composition , \"formula_pretty\" : comp . reduced_formula , \"formula_anonymous\" : comp . anonymized_formula , \"chemsys\" : \"-\" . join ( elsyms ), \"volume\" : meta_structure . volume , \"density\" : meta_structure . density , \"density_atomic\" : meta_structure . volume / meta_structure . num_sites , \"symmetry\" : symmetry , } return cls ( ** { k : v for k , v in data . items () if k in fields }, ** kwargs ) chemsys : str pydantic-field \u00b6 dash-delimited string of elements in the material. composition : Composition pydantic-field \u00b6 Full composition for the material. composition_reduced : Composition pydantic-field \u00b6 Simplified representation of the composition. density : float pydantic-field \u00b6 Density in grams per cm^3. density_atomic : float pydantic-field \u00b6 The atomic packing density in atoms per cm^3. elements : List [ pymatgen . core . periodic_table . Element ] pydantic-field \u00b6 List of elements in the material. formula_anonymous : str pydantic-field \u00b6 Anonymized representation of the formula. formula_pretty : str pydantic-field \u00b6 Cleaned representation of the formula. nelements : int pydantic-field \u00b6 Number of elements. nsites : int pydantic-field \u00b6 Total number of sites in the structure. symmetry : SymmetryData pydantic-field \u00b6 Symmetry data for this material. volume : float pydantic-field \u00b6 Total volume for this structure in Angstroms^3. Core definition of a Materials Document MaterialsDoc ( StructureMetadata ) pydantic-model \u00b6 Definition for a core Materials Document Source code in core/material.py class MaterialsDoc ( StructureMetadata ): \"\"\" Definition for a core Materials Document \"\"\" # Only material_id is required for all documents material_id : MPID = Field ( ... , description = \"The Materials Project ID of the material, used as a universal reference across property documents.\" \"This comes in the form: mp-******.\" , ) structure : Structure = Field ( ... , description = \"The structure of the this material.\" , ) deprecated : bool = Field ( True , description = \"Whether this materials document is deprecated.\" , ) deprecation_reasons : List [ Union [ DeprecationMessage , str ]] = Field ( None , description = \"List of deprecation tags detailing why this materials document isn't valid.\" , ) initial_structures : List [ Structure ] = Field ( [], description = \"Initial structures used in the DFT optimizations corresponding to this material.\" , ) task_ids : List [ MPID ] = Field ( [], description = \"List of Calculations IDs used to make this Materials Document.\" , ) deprecated_tasks : List [ str ] = Field ([], title = \"Deprecated Tasks\" ) calc_types : Mapping [ str , str ] = Field ( None , description = \"Calculation types for all the calculations that make up this material.\" , ) last_updated : datetime = Field ( description = \"Timestamp for when this document was last updated.\" , default_factory = datetime . utcnow , ) created_at : datetime = Field ( description = \"Timestamp for when this material document was first created.\" , default_factory = datetime . utcnow , ) origins : List [ PropertyOrigin ] = Field ( None , description = \"Dictionary for tracking the provenance of properties.\" ) warnings : List [ str ] = Field ( [], description = \"Any warnings related to this material.\" ) @classmethod def from_structure ( cls : Type [ T ], structure : Structure , material_id : MPID , ** kwargs ) -> T : # type: ignore[override] \"\"\" Builds a materials document using the minimal amount of information \"\"\" return super () . from_structure ( # type: ignore meta_structure = structure , material_id = material_id , structure = structure , ** kwargs , ) calc_types : Mapping [ str , str ] pydantic-field \u00b6 Calculation types for all the calculations that make up this material. created_at : datetime pydantic-field \u00b6 Timestamp for when this material document was first created. deprecated : bool pydantic-field \u00b6 Whether this materials document is deprecated. deprecation_reasons : List [ Union [ emmet . core . vasp . validation . DeprecationMessage , str ]] pydantic-field \u00b6 List of deprecation tags detailing why this materials document isn't valid. initial_structures : List [ pymatgen . core . structure . Structure ] pydantic-field \u00b6 Initial structures used in the DFT optimizations corresponding to this material. last_updated : datetime pydantic-field \u00b6 Timestamp for when this document was last updated. material_id : MPID pydantic-field required \u00b6 The Materials Project ID of the material, used as a universal reference across property documents.This comes in the form: mp- * *. origins : List [ emmet . core . material . PropertyOrigin ] pydantic-field \u00b6 Dictionary for tracking the provenance of properties. structure : Structure pydantic-field required \u00b6 The structure of the this material. task_ids : List [ emmet . core . mpid . MPID ] pydantic-field \u00b6 List of Calculations IDs used to make this Materials Document. warnings : List [ str ] pydantic-field \u00b6 Any warnings related to this material. from_structure ( structure , material_id , ** kwargs ) classmethod \u00b6 Builds a materials document using the minimal amount of information Source code in core/material.py @classmethod def from_structure ( cls : Type [ T ], structure : Structure , material_id : MPID , ** kwargs ) -> T : # type: ignore[override] \"\"\" Builds a materials document using the minimal amount of information \"\"\" return super () . from_structure ( # type: ignore meta_structure = structure , material_id = material_id , structure = structure , ** kwargs , ) MoleculeDoc ( MoleculeMetadata ) pydantic-model \u00b6 Definition for a core Molecule Document Source code in core/material.py class MoleculeDoc ( MoleculeMetadata ): \"\"\" Definition for a core Molecule Document \"\"\" # Only molecule_id is required for all documents molecule_id : MPID = Field ( ... , description = \"The ID of this molecule, used as a universal reference across property documents.\" \"This comes in the form of an MPID or int\" , ) molecule : Molecule = Field ( ... , description = \"The best (typically meaning lowest in energy) structure for this molecule\" , ) deprecated : bool = Field ( True , description = \"Whether this molecule document is deprecated.\" , ) # TODO: Why might a molecule be deprecated? deprecation_reasons : List [ str ] = Field ( None , description = \"List of deprecation tags detailing why this molecules document isn't valid\" , ) initial_molecules : List [ Molecule ] = Field ( [], description = \"Initial molecules used in the DFT geometry optimizations corresponding to this molecule\" , ) task_ids : List [ MPID ] = Field ( [], title = \"Calculation IDs\" , description = \"List of Calculations IDs used to make this Molecule Document\" , ) # TODO: Should this be MPID? deprecated_tasks : List [ str ] = Field ([], title = \"Deprecated Tasks\" ) calc_types : Mapping [ str , str ] = Field ( None , description = \"Calculation types for all the tasks that make up this molecule\" , ) last_updated : datetime = Field ( description = \"Timestamp for when this document was last updated\" , default_factory = datetime . utcnow , ) created_at : datetime = Field ( description = \"Timestamp for when this document was first created\" , default_factory = datetime . utcnow , ) origins : List [ PropertyOrigin ] = Field ( None , description = \"Dictionary for tracking the provenance of properties\" ) warnings : List [ str ] = Field ([], description = \"Any warnings related to this molecule\" ) @classmethod def from_molecule ( cls : Type [ S ], molecule : Molecule , molecule_id : MPID , ** kwargs ) -> S : # type: ignore[override] \"\"\" Builds a molecule document using the minimal amount of information \"\"\" return super () . from_molecule ( # type: ignore meta_molecule = molecule , molecule_id = molecule_id , molecule = molecule , ** kwargs ) calc_types : Mapping [ str , str ] pydantic-field \u00b6 Calculation types for all the tasks that make up this molecule created_at : datetime pydantic-field \u00b6 Timestamp for when this document was first created deprecated : bool pydantic-field \u00b6 Whether this molecule document is deprecated. deprecation_reasons : List [ str ] pydantic-field \u00b6 List of deprecation tags detailing why this molecules document isn't valid initial_molecules : List [ pymatgen . core . structure . Molecule ] pydantic-field \u00b6 Initial molecules used in the DFT geometry optimizations corresponding to this molecule last_updated : datetime pydantic-field \u00b6 Timestamp for when this document was last updated molecule : Molecule pydantic-field required \u00b6 The best (typically meaning lowest in energy) structure for this molecule molecule_id : MPID pydantic-field required \u00b6 The ID of this molecule, used as a universal reference across property documents.This comes in the form of an MPID or int origins : List [ emmet . core . material . PropertyOrigin ] pydantic-field \u00b6 Dictionary for tracking the provenance of properties task_ids : List [ emmet . core . mpid . MPID ] pydantic-field \u00b6 List of Calculations IDs used to make this Molecule Document warnings : List [ str ] pydantic-field \u00b6 Any warnings related to this molecule from_molecule ( molecule , molecule_id , ** kwargs ) classmethod \u00b6 Builds a molecule document using the minimal amount of information Source code in core/material.py @classmethod def from_molecule ( cls : Type [ S ], molecule : Molecule , molecule_id : MPID , ** kwargs ) -> S : # type: ignore[override] \"\"\" Builds a molecule document using the minimal amount of information \"\"\" return super () . from_molecule ( # type: ignore meta_molecule = molecule , molecule_id = molecule_id , molecule = molecule , ** kwargs ) PropertyOrigin ( BaseModel ) pydantic-model \u00b6 Provenance document for the origin of properties in a material document Source code in core/material.py class PropertyOrigin ( BaseModel ): \"\"\" Provenance document for the origin of properties in a material document \"\"\" name : str = Field ( ... , description = \"The property name\" ) task_id : MPID = Field ( ... , description = \"The calculation ID this property comes from\" ) last_updated : datetime = Field ( description = \"The timestamp when this calculation was last updated\" , default_factory = datetime . utcnow , ) last_updated : datetime pydantic-field \u00b6 The timestamp when this calculation was last updated name : str pydantic-field required \u00b6 The property name task_id : MPID pydantic-field required \u00b6 The calculation ID this property comes from Core definition of a Thermo Document DecompositionProduct ( BaseModel ) pydantic-model \u00b6 Entry metadata for a decomposition process Source code in core/thermo.py class DecompositionProduct ( BaseModel ): \"\"\" Entry metadata for a decomposition process \"\"\" material_id : MPID = Field ( None , description = \"The Materials Project ID for the material this decomposition points to.\" , ) formula : str = Field ( None , description = \"The formula of the decomposed material this material decomposes to.\" , ) amount : float = Field ( None , description = \"The amount of the decomposed material by formula units this this material decomposes to.\" , ) amount : float pydantic-field \u00b6 The amount of the decomposed material by formula units this this material decomposes to. formula : str pydantic-field \u00b6 The formula of the decomposed material this material decomposes to. material_id : MPID pydantic-field \u00b6 The Materials Project ID for the material this decomposition points to. PhaseDiagramDoc ( BaseModel ) pydantic-model \u00b6 A phase diagram document Source code in core/thermo.py class PhaseDiagramDoc ( BaseModel ): \"\"\" A phase diagram document \"\"\" property_name = \"phase_diagram\" chemsys : str = Field ( ... , title = \"Chemical System\" , description = \"Dash-delimited string of elements in the material\" , ) phase_diagram : PhaseDiagram = Field ( ... , description = \"Phase diagram for the chemical system.\" , ) last_updated : datetime = Field ( description = \"Timestamp for the most recent calculation update for this property\" , default_factory = datetime . utcnow , ) chemsys : str pydantic-field required \u00b6 Dash-delimited string of elements in the material last_updated : datetime pydantic-field \u00b6 Timestamp for the most recent calculation update for this property phase_diagram : PhaseDiagram pydantic-field required \u00b6 Phase diagram for the chemical system. ThermoDoc ( PropertyDoc ) pydantic-model \u00b6 A thermo entry document Source code in core/thermo.py class ThermoDoc ( PropertyDoc ): \"\"\" A thermo entry document \"\"\" property_name = \"thermo\" uncorrected_energy_per_atom : float = Field ( ... , description = \"The total DFT energy of this material per atom in eV/atom.\" ) energy_per_atom : float = Field ( ... , description = \"The total corrected DFT energy of this material per atom in eV/atom.\" , ) energy_uncertainy_per_atom : float = Field ( None , description = \"\" ) formation_energy_per_atom : float = Field ( None , description = \"The formation energy per atom in eV/atom.\" ) energy_above_hull : float = Field ( ... , description = \"The energy above the hull in eV/Atom.\" ) is_stable : bool = Field ( False , description = \"Flag for whether this material is on the hull and therefore stable.\" , ) equilibrium_reaction_energy_per_atom : float = Field ( None , description = \"The reaction energy of a stable entry from the neighboring equilibrium stable materials in eV.\" \" Also known as the inverse distance to hull.\" , ) decomposes_to : List [ DecompositionProduct ] = Field ( None , description = \"List of decomposition data for this material. Only valid for metastable or unstable material.\" , ) decomposition_enthalpy : float = Field ( None , description = \"Decomposition enthalpy as defined by `get_decomp_and_phase_separation_energy` in pymatgen.\" , ) decomposition_enthalpy_decomposes_to : List [ DecompositionProduct ] = Field ( None , description = \"List of decomposition data associated with the decomposition_enthalpy quantity.\" , ) energy_type : str = Field ( ... , description = \"The type of calculation this energy evaluation comes from.\" , ) entry_types : List [ str ] = Field ( description = \"List of available energy types computed for this material.\" ) entries : Dict [ str , Union [ ComputedEntry , ComputedStructureEntry ]] = Field ( ... , description = \"List of all entries that are valid for this material.\" \" The keys for this dictionary are names of various calculation types.\" , ) @classmethod def from_entries ( cls , entries : List [ Union [ ComputedEntry , ComputedStructureEntry ]], ** kwargs ): entries_by_comp = defaultdict ( list ) for e in entries : entries_by_comp [ e . composition . reduced_formula ] . append ( e ) # Only use lowest entry per composition to speed up QHull in Phase Diagram reduced_entries = [ sorted ( comp_entries , key = lambda e : e . energy_per_atom )[ 0 ] for comp_entries in entries_by_comp . values () ] pd = PhaseDiagram ( reduced_entries ) docs = [] entries_by_mpid = defaultdict ( list ) for e in entries : entries_by_mpid [ e . data [ \"material_id\" ]] . append ( e ) entry_quality_scores = { \"GGA\" : 1 , \"GGA+U\" : 2 , \"SCAN\" : 3 , \"R2SCAN\" : 4 } def _energy_eval ( entry : ComputedStructureEntry ): \"\"\" Helper function to order entries for thermo energy data selection - Run type - LASPH - Energy \"\"\" return ( - 1 * entry_quality_scores . get ( entry . data [ \"run_type\" ], 0 ), - 1 * int ( entry . data . get ( \"aspherical\" , False )), entry . energy , ) for material_id , entry_group in entries_by_mpid . items (): sorted_entries = sorted ( entry_group , key = _energy_eval ) blessed_entry = sorted_entries [ 0 ] ( decomp , ehull ) = pd . get_decomp_and_e_above_hull ( blessed_entry ) d = { \"material_id\" : material_id , \"uncorrected_energy_per_atom\" : blessed_entry . uncorrected_energy / blessed_entry . composition . num_atoms , \"energy_per_atom\" : blessed_entry . energy / blessed_entry . composition . num_atoms , \"formation_energy_per_atom\" : pd . get_form_energy_per_atom ( blessed_entry ), \"energy_above_hull\" : ehull , \"is_stable\" : blessed_entry in pd . stable_entries , } if \"last_updated\" in blessed_entry . data : d [ \"last_updated\" ] = blessed_entry . data [ \"last_updated\" ] # Store different info if stable vs decomposes if d [ \"is_stable\" ]: d [ \"equilibrium_reaction_energy_per_atom\" ] = pd . get_equilibrium_reaction_energy ( blessed_entry ) else : d [ \"decomposes_to\" ] = [ { \"material_id\" : de . data [ \"material_id\" ], \"formula\" : de . composition . formula , \"amount\" : amt , } for de , amt in decomp . items () ] try : decomp , energy = pd . get_decomp_and_phase_separation_energy ( blessed_entry ) d [ \"decomposition_enthalpy\" ] = energy d [ \"decomposition_enthalpy_decomposes_to\" ] = [ { \"material_id\" : de . data [ \"material_id\" ], \"formula\" : de . composition . formula , \"amount\" : amt , } for de , amt in decomp . items () ] except ValueError : # try/except so this quantity does not take down the builder if it fails: # it includes an optimization step that can be fragile in some instances, # most likely failure is ValueError, \"invalid value encountered in true_divide\" d [ \"warnings\" ] = [ \"Could not calculate decomposition enthalpy for this entry.\" ] d [ \"energy_type\" ] = blessed_entry . parameters . get ( \"run_type\" , \"Unknown\" ) d [ \"entry_types\" ] = [] d [ \"entries\" ] = {} # Currently, each entry group contains a single entry due to how the compatability scheme works for entry in entry_group : d [ \"entry_types\" ] . append ( entry . parameters . get ( \"run_type\" , \"Unknown\" )) d [ \"entries\" ][ entry . parameters . get ( \"run_type\" , \"Unknown\" )] = entry d [ \"origins\" ] = [ PropertyOrigin ( name = \"energy\" , task_id = blessed_entry . data [ \"task_id\" ], last_updated = d . get ( \"last_updated\" , datetime . utcnow ()), ) ] docs . append ( ThermoDoc . from_structure ( meta_structure = blessed_entry . structure , ** d , ** kwargs ) ) # Construct new phase diagram with all of the entries, not just those on the hull pd_computed_data = pd . _compute () pd_computed_data [ \"all_entries\" ] = entries new_pd = PhaseDiagram ( entries , elements = pd . elements , computed_data = pd_computed_data ) return docs , new_pd decomposes_to : List [ emmet . core . thermo . DecompositionProduct ] pydantic-field \u00b6 List of decomposition data for this material. Only valid for metastable or unstable material. decomposition_enthalpy : float pydantic-field \u00b6 Decomposition enthalpy as defined by get_decomp_and_phase_separation_energy in pymatgen. decomposition_enthalpy_decomposes_to : List [ emmet . core . thermo . DecompositionProduct ] pydantic-field \u00b6 List of decomposition data associated with the decomposition_enthalpy quantity. energy_above_hull : float pydantic-field required \u00b6 The energy above the hull in eV/Atom. energy_per_atom : float pydantic-field required \u00b6 The total corrected DFT energy of this material per atom in eV/atom. energy_type : str pydantic-field required \u00b6 The type of calculation this energy evaluation comes from. entries : Dict [ str , Union [ pymatgen . entries . computed_entries . ComputedEntry , pymatgen . entries . computed_entries . ComputedStructureEntry ]] pydantic-field required \u00b6 List of all entries that are valid for this material. The keys for this dictionary are names of various calculation types. entry_types : List [ str ] pydantic-field required \u00b6 List of available energy types computed for this material. equilibrium_reaction_energy_per_atom : float pydantic-field \u00b6 The reaction energy of a stable entry from the neighboring equilibrium stable materials in eV. Also known as the inverse distance to hull. formation_energy_per_atom : float pydantic-field \u00b6 The formation energy per atom in eV/atom. is_stable : bool pydantic-field \u00b6 Flag for whether this material is on the hull and therefore stable. uncorrected_energy_per_atom : float pydantic-field required \u00b6 The total DFT energy of this material per atom in eV/atom. Core definition of a Provenance Document Author ( BaseModel ) pydantic-model \u00b6 Author information Source code in core/provenance.py class Author ( BaseModel ): \"\"\" Author information \"\"\" name : str = Field ( None ) email : str = Field ( None ) Database ( ValueEnum ) \u00b6 Database identifiers for provenance IDs Source code in core/provenance.py class Database ( ValueEnum ): \"\"\" Database identifiers for provenance IDs \"\"\" ICSD = \"icsd\" Pauling_Files = \"pf\" COD = \"cod\" History ( BaseModel ) pydantic-model \u00b6 History of the material provenance Source code in core/provenance.py class History ( BaseModel ): \"\"\" History of the material provenance \"\"\" name : str url : str description : Optional [ Dict ] = Field ( None , description = \"Dictionary of exra data for this history node.\" ) @root_validator ( pre = True ) def str_to_dict ( cls , values ): if isinstance ( values . get ( \"description\" ), str ): values [ \"description\" ] = { \"string\" : values . get ( \"description\" )} return values description : Dict pydantic-field \u00b6 Dictionary of exra data for this history node. ProvenanceDoc ( PropertyDoc ) pydantic-model \u00b6 A provenance property block Source code in core/provenance.py class ProvenanceDoc ( PropertyDoc ): \"\"\" A provenance property block \"\"\" property_name = \"provenance\" created_at : datetime = Field ( ... , description = \"creation date for the first structure corresponding to this material\" , ) references : List [ str ] = Field ( [], description = \"Bibtex reference strings for this material\" ) authors : List [ Author ] = Field ([], description = \"List of authors for this material\" ) remarks : List [ str ] = Field ( [], description = \"List of remarks for the provenance of this material\" ) tags : List [ str ] = Field ([]) theoretical : bool = Field ( True , description = \"If this material has any experimental provenance or not\" ) database_IDs : Dict [ Database , List [ str ]] = Field ( dict (), description = \"Database IDs corresponding to this material\" ) history : List [ History ] = Field ( [], description = \"List of history nodes specifying the transformations or orignation\" \" of this material for the entry closest matching the material input\" , ) @validator ( \"authors\" ) def remove_duplicate_authors ( cls , authors ): authors_dict = { entry . name . lower (): entry for entry in authors } return list ( authors_dict . values ()) @classmethod def from_SNLs ( cls , material_id : MPID , structure : Structure , snls : List [ SNLDict ], ** kwargs ) -> \"ProvenanceDoc\" : \"\"\" Converts legacy Pymatgen SNLs into a single provenance document \"\"\" assert ( len ( snls ) > 0 ), \"Error must provide a non-zero list of SNLs to convert from SNLs\" # Choose earliest created_at created_at = min ([ snl . about . created_at for snl in snls ]) # last_updated = max([snl.about.created_at for snl in snls]) # Choose earliest history history = sorted ( snls , key = lambda snl : snl . about . created_at )[ 0 ] . about . history # Aggregate all references into one dict to remove duplicates refs = {} for snl in snls : try : set_strict_mode ( False ) entries = parse_string ( snl . about . references , bib_format = \"bibtex\" ) refs . update ( entries . entries ) except Exception as e : warnings . warn ( f \"Failed parsing bibtex: { snl . about . references } due to { e } \" ) bib_data = BibliographyData ( entries = refs ) references = [ ref . to_string ( \"bibtex\" ) for ref in bib_data . entries . values ()] # TODO: Maybe we should combine this robocrystallographer? # TODO: Refine these tags / remarks remarks = list ( set ([ remark for snl in snls for remark in snl . about . remarks ])) tags = [ r for r in remarks if len ( r ) < 140 ] authors = [ entry for snl in snls for entry in snl . about . authors ] # Check if this entry is experimental exp_vals = [] for snl in snls : for entry in snl . about . history : if entry . description is not None : exp_vals . append ( entry . description . get ( \"experimental\" , False )) experimental = any ( exp_vals ) # Aggregate all the database IDs snl_ids = { snl . snl_id for snl in snls } db_ids = { Database ( db_id ): [ snl_id for snl_id in snl_ids if db_id in snl_id ] for db_id in map ( str , Database ) # type: ignore } # remove Nones and empty lists db_ids = { k : list ( filter ( None , v )) for k , v in db_ids . items ()} db_ids = { k : v for k , v in db_ids . items () if len ( v ) > 0 } fields = { \"created_at\" : created_at , \"references\" : references , \"authors\" : authors , \"remarks\" : remarks , \"tags\" : tags , \"database_IDs\" : db_ids , \"theoretical\" : not experimental , \"history\" : history , } return super () . from_structure ( material_id = material_id , meta_structure = structure , ** fields , ** kwargs ) authors : List [ emmet . core . provenance . Author ] pydantic-field \u00b6 List of authors for this material created_at : datetime pydantic-field required \u00b6 creation date for the first structure corresponding to this material database_IDs : Dict [ emmet . core . provenance . Database , List [ str ]] pydantic-field \u00b6 Database IDs corresponding to this material history : List [ emmet . core . provenance . History ] pydantic-field \u00b6 List of history nodes specifying the transformations or orignation of this material for the entry closest matching the material input references : List [ str ] pydantic-field \u00b6 Bibtex reference strings for this material remarks : List [ str ] pydantic-field \u00b6 List of remarks for the provenance of this material theoretical : bool pydantic-field \u00b6 If this material has any experimental provenance or not from_SNLs ( material_id , structure , snls , ** kwargs ) classmethod \u00b6 Converts legacy Pymatgen SNLs into a single provenance document Source code in core/provenance.py @classmethod def from_SNLs ( cls , material_id : MPID , structure : Structure , snls : List [ SNLDict ], ** kwargs ) -> \"ProvenanceDoc\" : \"\"\" Converts legacy Pymatgen SNLs into a single provenance document \"\"\" assert ( len ( snls ) > 0 ), \"Error must provide a non-zero list of SNLs to convert from SNLs\" # Choose earliest created_at created_at = min ([ snl . about . created_at for snl in snls ]) # last_updated = max([snl.about.created_at for snl in snls]) # Choose earliest history history = sorted ( snls , key = lambda snl : snl . about . created_at )[ 0 ] . about . history # Aggregate all references into one dict to remove duplicates refs = {} for snl in snls : try : set_strict_mode ( False ) entries = parse_string ( snl . about . references , bib_format = \"bibtex\" ) refs . update ( entries . entries ) except Exception as e : warnings . warn ( f \"Failed parsing bibtex: { snl . about . references } due to { e } \" ) bib_data = BibliographyData ( entries = refs ) references = [ ref . to_string ( \"bibtex\" ) for ref in bib_data . entries . values ()] # TODO: Maybe we should combine this robocrystallographer? # TODO: Refine these tags / remarks remarks = list ( set ([ remark for snl in snls for remark in snl . about . remarks ])) tags = [ r for r in remarks if len ( r ) < 140 ] authors = [ entry for snl in snls for entry in snl . about . authors ] # Check if this entry is experimental exp_vals = [] for snl in snls : for entry in snl . about . history : if entry . description is not None : exp_vals . append ( entry . description . get ( \"experimental\" , False )) experimental = any ( exp_vals ) # Aggregate all the database IDs snl_ids = { snl . snl_id for snl in snls } db_ids = { Database ( db_id ): [ snl_id for snl_id in snl_ids if db_id in snl_id ] for db_id in map ( str , Database ) # type: ignore } # remove Nones and empty lists db_ids = { k : list ( filter ( None , v )) for k , v in db_ids . items ()} db_ids = { k : v for k , v in db_ids . items () if len ( v ) > 0 } fields = { \"created_at\" : created_at , \"references\" : references , \"authors\" : authors , \"remarks\" : remarks , \"tags\" : tags , \"database_IDs\" : db_ids , \"theoretical\" : not experimental , \"history\" : history , } return super () . from_structure ( material_id = material_id , meta_structure = structure , ** fields , ** kwargs ) SNLAbout ( BaseModel ) pydantic-model \u00b6 A data dictionary definining extra fields in a SNL Source code in core/provenance.py class SNLAbout ( BaseModel ): \"\"\"A data dictionary definining extra fields in a SNL\"\"\" references : str = Field ( \"\" , description = \"Bibtex reference strings for this material.\" ) authors : List [ Author ] = Field ([], description = \"List of authors for this material.\" ) remarks : List [ str ] = Field ( [], description = \"List of remarks for the provenance of this material.\" ) tags : List [ str ] = Field ([]) database_IDs : Dict [ Database , List [ str ]] = Field ( dict (), description = \"Database IDs corresponding to this material.\" ) history : List [ History ] = Field ( [], description = \"List of history nodes specifying the transformations or orignation\" \" of this material for the entry closest matching the material input.\" , ) created_at : datetime = Field ( default_factory = datetime . utcnow , description = \"The creation date for this SNL.\" ) @validator ( \"created_at\" , pre = True ) def convert_monty_date ( cls , v ): if isinstance ( v , dict ): if v . get ( \"@module\" , \"datetime\" ) and v . get ( \"@class\" , \"datetime\" ): return datetime . fromisoformat ( v [ \"string\" ]) raise ValueError ( \"Improper monty dict datetime\" ) return v authors : List [ emmet . core . provenance . Author ] pydantic-field \u00b6 List of authors for this material. created_at : datetime pydantic-field \u00b6 The creation date for this SNL. database_IDs : Dict [ emmet . core . provenance . Database , List [ str ]] pydantic-field \u00b6 Database IDs corresponding to this material. history : List [ emmet . core . provenance . History ] pydantic-field \u00b6 List of history nodes specifying the transformations or orignation of this material for the entry closest matching the material input. references : str pydantic-field \u00b6 Bibtex reference strings for this material. remarks : List [ str ] pydantic-field \u00b6 List of remarks for the provenance of this material. SNLDict ( BaseModel ) pydantic-model \u00b6 Pydantic validated dictionary for SNL Source code in core/provenance.py class SNLDict ( BaseModel ): \"\"\"Pydantic validated dictionary for SNL\"\"\" about : SNLAbout snl_id : str = Field ( ... , description = \"The SNL ID for this entry\" ) snl_id : str pydantic-field required \u00b6 The SNL ID for this entry Core definition for Polar property Document DielectricDoc ( PropertyDoc ) pydantic-model \u00b6 A dielectric property block Source code in core/polar.py class DielectricDoc ( PropertyDoc ): \"\"\" A dielectric property block \"\"\" property_name = \"dielectric\" total : Matrix3D = Field ( description = \"Total dielectric tensor.\" ) ionic : Matrix3D = Field ( description = \"Ionic contribution to dielectric tensor.\" ) electronic : Matrix3D = Field ( description = \"Electronic contribution to dielectric tensor.\" ) e_total : float = Field ( description = \"Total electric permittivity.\" ) e_ionic : float = Field ( description = \"Electric permittivity from atomic rearrangement.\" ) e_electronic : float = Field ( description = \"Electric permittivity due to electrons rearrangement.\" ) n : float = Field ( description = \"Refractive index.\" ) @classmethod def from_ionic_and_electronic ( cls , material_id : MPID , ionic : Matrix3D , electronic : Matrix3D , structure : Structure , ** kwargs , ): ionic_tensor = Tensor ( ionic ) . convert_to_ieee ( structure ) electronic_tensor = Tensor ( electronic ) . convert_to_ieee ( structure ) total = ionic_tensor + electronic_tensor return super () . from_structure ( meta_structure = structure , material_id = material_id , ** { \"total\" : total . tolist (), \"ionic\" : ionic_tensor . tolist (), \"electronic\" : electronic_tensor . tolist (), \"e_total\" : np . average ( np . diagonal ( total )), \"e_ionic\" : np . average ( np . diagonal ( ionic_tensor )), \"e_electronic\" : np . average ( np . diagonal ( electronic_tensor )), \"n\" : np . sqrt ( np . average ( np . diagonal ( electronic_tensor ))), }, ** kwargs , ) e_electronic : float pydantic-field required \u00b6 Electric permittivity due to electrons rearrangement. e_ionic : float pydantic-field required \u00b6 Electric permittivity from atomic rearrangement. e_total : float pydantic-field required \u00b6 Total electric permittivity. electronic : Tuple [ Tuple [ float , float , float ], Tuple [ float , float , float ], Tuple [ float , float , float ]] pydantic-field required \u00b6 Electronic contribution to dielectric tensor. ionic : Tuple [ Tuple [ float , float , float ], Tuple [ float , float , float ], Tuple [ float , float , float ]] pydantic-field required \u00b6 Ionic contribution to dielectric tensor. n : float pydantic-field required \u00b6 Refractive index. total : Tuple [ Tuple [ float , float , float ], Tuple [ float , float , float ], Tuple [ float , float , float ]] pydantic-field required \u00b6 Total dielectric tensor. PiezoelectricDoc ( PropertyDoc ) pydantic-model \u00b6 A dielectric package block Source code in core/polar.py class PiezoelectricDoc ( PropertyDoc ): \"\"\" A dielectric package block \"\"\" property_name = \"piezoelectric\" total : PiezoTensor = Field ( description = \"Total piezoelectric tensor in C/m\u00b2\" ) ionic : PiezoTensor = Field ( description = \"Ionic contribution to piezoelectric tensor in C/m\u00b2\" ) electronic : PiezoTensor = Field ( description = \"Electronic contribution to piezoelectric tensor in C/m\u00b2\" ) e_ij_max : float = Field ( description = \"Piezoelectric modulus\" ) max_direction : List [ int ] = Field ( description = \"Miller direction for maximum piezo response\" ) strain_for_max : List [ float ] = Field ( description = \"Normalized strain direction for maximum piezo repsonse\" ) @classmethod def from_ionic_and_electronic ( cls , material_id : MPID , ionic : PiezoTensor , electronic : PiezoTensor , structure : Structure , ** kwargs , ): ionic_tensor = BasePiezoTensor . from_vasp_voigt ( ionic ) electronic_tensor = BasePiezoTensor . from_vasp_voigt ( electronic ) total = ionic_tensor + electronic_tensor # Symmeterize Convert to IEEE orientation total = total . convert_to_ieee ( structure ) ionic_tensor = ionic_tensor . convert_to_ieee ( structure ) electronic_tensor = electronic_tensor . convert_to_ieee ( structure ) directions , charges , strains = np . linalg . svd ( total . voigt , full_matrices = False ) max_index = np . argmax ( np . abs ( charges )) max_direction = directions [ max_index ] # Allow a max miller index of 10 min_val = np . abs ( max_direction ) min_val = min_val [ min_val > ( np . max ( min_val ) / SETTINGS . MAX_PIEZO_MILLER )] min_val = np . min ( min_val ) return super () . from_structure ( meta_structure = structure , material_id = material_id , ** { \"total\" : total . zeroed () . voigt . tolist (), \"ionic\" : ionic_tensor . zeroed () . voigt . tolist (), \"electronic\" : electronic_tensor . zeroed () . voigt . tolist (), \"e_ij_max\" : charges [ max_index ], \"max_direction\" : tuple ( np . round ( max_direction / min_val )), \"strain_for_max\" : tuple ( strains [ max_index ]), }, ** kwargs , ) e_ij_max : float pydantic-field required \u00b6 Piezoelectric modulus electronic : List [ List [ float ]] pydantic-field required \u00b6 Electronic contribution to piezoelectric tensor in C/m\u00b2 ionic : List [ List [ float ]] pydantic-field required \u00b6 Ionic contribution to piezoelectric tensor in C/m\u00b2 max_direction : List [ int ] pydantic-field required \u00b6 Miller direction for maximum piezo response strain_for_max : List [ float ] pydantic-field required \u00b6 Normalized strain direction for maximum piezo repsonse total : List [ List [ float ]] pydantic-field required \u00b6 Total piezoelectric tensor in C/m\u00b2","title":"Core"},{"location":"core/#emmet-core","text":"The core module defines the data models for the Materials API (MAPI):","title":"Emmet-Core"},{"location":"core/#emmet.core.symmetry.CrystalSystem","text":"The crystal system of the lattice Source code in core/symmetry.py class CrystalSystem ( ValueEnum ): \"\"\" The crystal system of the lattice \"\"\" tri = \"Triclinic\" mono = \"Monoclinic\" ortho = \"Orthorhombic\" tet = \"Tetragonal\" trig = \"Trigonal\" hex_ = \"Hexagonal\" cubic = \"Cubic\"","title":"CrystalSystem"},{"location":"core/#emmet.core.symmetry.PointGroupData","text":"Defines symmetry for a molecule document Source code in core/symmetry.py class PointGroupData ( BaseModel ): \"\"\" Defines symmetry for a molecule document \"\"\" point_group : str = Field ( None , title = \"Point Group Symbol\" , description = \"The point group for the lattice\" ) rotation_number : float = Field ( None , title = \"Rotational Symmetry Number\" , description = \"Rotational symmetry number for the molecule\" , ) linear : bool = Field ( None , title = \"Molecule Linearity\" , description = \"Is the molecule linear?\" ) tolerance : float = Field ( None , title = \"Point Group Analyzer Tolerance\" , description = \"Distance tolerance to consider sites as symmetrically equivalent.\" , ) eigen_tolerance : float = Field ( None , title = \"Interia Tensor Eigenvalue Tolerance\" , description = \"Tolerance to compare eigen values of the inertia tensor.\" , ) matrix_tolerance : float = Field ( None , title = \"Symmetry Operation Matrix Element Tolerance\" , description = \"Tolerance used to generate the full set of symmetry operations of the point group.\" , ) @classmethod def from_molecule ( cls , molecule : Molecule ) -> \"PointGroupData\" : tol = SETTINGS . PGATOL eigentol = SETTINGS . PGAEIGENTOL matrixtol = SETTINGS . PGAMATRIXTOL pga = PointGroupAnalyzer ( molecule , tolerance = tol , eigen_tolerance = eigentol , matrix_tolerance = matrixtol , ) symmetry : Dict [ str , Any ] = { \"tolerance\" : tol , \"eigen_tolerance\" : eigentol , \"matrix_tolerance\" : matrixtol , \"point_group\" : pga . sch_symbol , } rotational_symmetry_numbers = { 1.0 : [ \"C1\" , \"Cs\" , \"Ci\" , \"C*v\" , \"S2\" ], 2.0 : [ \"C2\" , \"C2h\" , \"C2v\" , \"S4\" , \"D*h\" ], 3.0 : [ \"C3\" , \"C3h\" , \"C3v\" , \"S6\" ], 4.0 : [ \"C4v\" , \"D4h\" , \"D4d\" , \"D2\" , \"D2h\" , \"D2d\" ], 5.0 : [ \"C5v\" , \"Ih\" ], 6.0 : [ \"D3\" , \"D3h\" , \"D3d\" ], 10.0 : [ \"D5h\" , \"D5d\" ], 12.0 : [ \"T\" , \"Td\" , \"Th\" , \"D6h\" ], 14.0 : [ \"D7h\" ], 16.0 : [ \"D8h\" ], 24.0 : [ \"Oh\" ], float ( \"inf\" ): [ \"Kh\" ], } r = 1.0 for rot_num , point_groups in rotational_symmetry_numbers . items (): if symmetry [ \"point_group\" ] in point_groups : r = rot_num break if symmetry [ \"point_group\" ] in [ \"C*v\" , \"D*h\" ]: linear = True else : linear = False symmetry [ \"rotation_number\" ] = float ( r ) symmetry [ \"linear\" ] = linear return PointGroupData ( ** symmetry )","title":"PointGroupData"},{"location":"core/#emmet.core.symmetry.PointGroupData.eigen_tolerance","text":"Tolerance to compare eigen values of the inertia tensor.","title":"eigen_tolerance"},{"location":"core/#emmet.core.symmetry.PointGroupData.linear","text":"Is the molecule linear?","title":"linear"},{"location":"core/#emmet.core.symmetry.PointGroupData.matrix_tolerance","text":"Tolerance used to generate the full set of symmetry operations of the point group.","title":"matrix_tolerance"},{"location":"core/#emmet.core.symmetry.PointGroupData.point_group","text":"The point group for the lattice","title":"point_group"},{"location":"core/#emmet.core.symmetry.PointGroupData.rotation_number","text":"Rotational symmetry number for the molecule","title":"rotation_number"},{"location":"core/#emmet.core.symmetry.PointGroupData.tolerance","text":"Distance tolerance to consider sites as symmetrically equivalent.","title":"tolerance"},{"location":"core/#emmet.core.symmetry.SymmetryData","text":"Defines a symmetry data set for materials documents Source code in core/symmetry.py class SymmetryData ( BaseModel ): \"\"\" Defines a symmetry data set for materials documents \"\"\" crystal_system : CrystalSystem = Field ( None , title = \"Crystal System\" , description = \"The crystal system for this lattice.\" ) symbol : str = Field ( None , title = \"Space Group Symbol\" , description = \"The spacegroup symbol for the lattice.\" , ) number : int = Field ( None , title = \"Space Group Number\" , description = \"The spacegroup number for the lattice.\" , ) point_group : str = Field ( None , title = \"Point Group Symbol\" , description = \"The point group for the lattice.\" ) symprec : float = Field ( None , title = \"Symmetry Finding Precision\" , description = \"The precision given to spglib to determine the symmetry of this lattice.\" , ) version : str = Field ( None , title = \"SPGLib version\" ) @classmethod def from_structure ( cls , structure : Structure ) -> \"SymmetryData\" : symprec = SETTINGS . SYMPREC sg = SpacegroupAnalyzer ( structure , symprec = symprec ) symmetry : Dict [ str , Any ] = { \"symprec\" : symprec } if not sg . get_symmetry_dataset (): sg = SpacegroupAnalyzer ( structure , 1e-3 , 1 ) symmetry [ \"symprec\" ] = 1e-3 symmetry . update ( { \"source\" : \"spglib\" , \"symbol\" : sg . get_space_group_symbol (), \"number\" : sg . get_space_group_number (), \"point_group\" : sg . get_point_group_symbol (), \"crystal_system\" : CrystalSystem ( sg . get_crystal_system () . title ()), \"hall\" : sg . get_hall (), \"version\" : spglib . __version__ , } ) return SymmetryData ( ** symmetry )","title":"SymmetryData"},{"location":"core/#emmet.core.symmetry.SymmetryData.crystal_system","text":"The crystal system for this lattice.","title":"crystal_system"},{"location":"core/#emmet.core.symmetry.SymmetryData.number","text":"The spacegroup number for the lattice.","title":"number"},{"location":"core/#emmet.core.symmetry.SymmetryData.point_group","text":"The point group for the lattice.","title":"point_group"},{"location":"core/#emmet.core.symmetry.SymmetryData.symbol","text":"The spacegroup symbol for the lattice.","title":"symbol"},{"location":"core/#emmet.core.symmetry.SymmetryData.symprec","text":"The precision given to spglib to determine the symmetry of this lattice. Core definition of Structure metadata","title":"symprec"},{"location":"core/#emmet.core.structure.MoleculeMetadata","text":"Mix-in class for molecule metadata Source code in core/structure.py class MoleculeMetadata ( EmmetBaseModel ): \"\"\" Mix-in class for molecule metadata \"\"\" charge : float = Field ( None , description = \"Charge of the molecule\" ) spin_multiplicity : int = Field ( None , description = \"Spin multiplicity of the molecule\" ) natoms : int = Field ( None , description = \"Total number of atoms in the molecule\" ) elements : List [ Element ] = Field ( None , description = \"List of elements in the molecule\" ) nelements : int = Field ( None , title = \"Number of Elements\" ) composition : Composition = Field ( None , description = \"Full composition for the molecule\" ) formula_alphabetical : str = Field ( None , title = \"Alphabetical Formula\" , description = \"Alphabetical molecular formula\" , ) chemsys : str = Field ( None , title = \"Chemical System\" , description = \"dash-delimited string of elements in the molecule\" , ) symmetry : PointGroupData = Field ( None , description = \"Symmetry data for this molecule\" ) @classmethod def from_molecule ( cls : Type [ S ], meta_molecule : Molecule , fields : Optional [ List [ str ]] = None , ** kwargs ) -> T : fields = ( [ \"charge\" , \"spin_multiplicity\" , \"natoms\" , \"elements\" , \"nelements\" , \"composition\" , \"formula_alphabetical\" , \"chemsys\" , \"symmetry\" , ] if fields is None else fields ) comp = meta_molecule . composition elsyms = sorted ( set ([ e . symbol for e in comp . elements ])) symmetry = PointGroupData . from_molecule ( meta_molecule ) data = { \"charge\" : meta_molecule . charge , \"spin_multiplicity\" : meta_molecule . spin_multiplicity , \"nsites\" : len ( meta_molecule ), \"elements\" : elsyms , \"nelements\" : len ( elsyms ), \"composition\" : comp , \"formula_alphabetical\" : comp . alphabetical_formula , \"chemsys\" : \"-\" . join ( elsyms ), \"symmetry\" : symmetry , } return cls ( ** { k : v for k , v in data . items () if k in fields }, ** kwargs )","title":"MoleculeMetadata"},{"location":"core/#emmet.core.structure.MoleculeMetadata.charge","text":"Charge of the molecule","title":"charge"},{"location":"core/#emmet.core.structure.MoleculeMetadata.chemsys","text":"dash-delimited string of elements in the molecule","title":"chemsys"},{"location":"core/#emmet.core.structure.MoleculeMetadata.composition","text":"Full composition for the molecule","title":"composition"},{"location":"core/#emmet.core.structure.MoleculeMetadata.elements","text":"List of elements in the molecule","title":"elements"},{"location":"core/#emmet.core.structure.MoleculeMetadata.formula_alphabetical","text":"Alphabetical molecular formula","title":"formula_alphabetical"},{"location":"core/#emmet.core.structure.MoleculeMetadata.natoms","text":"Total number of atoms in the molecule","title":"natoms"},{"location":"core/#emmet.core.structure.MoleculeMetadata.spin_multiplicity","text":"Spin multiplicity of the molecule","title":"spin_multiplicity"},{"location":"core/#emmet.core.structure.MoleculeMetadata.symmetry","text":"Symmetry data for this molecule","title":"symmetry"},{"location":"core/#emmet.core.structure.StructureMetadata","text":"Mix-in class for structure metadata Source code in core/structure.py class StructureMetadata ( EmmetBaseModel ): \"\"\" Mix-in class for structure metadata \"\"\" # Structure metadata nsites : int = Field ( None , description = \"Total number of sites in the structure.\" ) elements : List [ Element ] = Field ( None , description = \"List of elements in the material.\" ) nelements : int = Field ( None , description = \"Number of elements.\" ) composition : Composition = Field ( None , description = \"Full composition for the material.\" ) composition_reduced : Composition = Field ( None , title = \"Reduced Composition\" , description = \"Simplified representation of the composition.\" , ) formula_pretty : str = Field ( None , title = \"Pretty Formula\" , description = \"Cleaned representation of the formula.\" , ) formula_anonymous : str = Field ( None , title = \"Anonymous Formula\" , description = \"Anonymized representation of the formula.\" , ) chemsys : str = Field ( None , title = \"Chemical System\" , description = \"dash-delimited string of elements in the material.\" , ) volume : float = Field ( None , title = \"Volume\" , description = \"Total volume for this structure in Angstroms^3.\" , ) density : float = Field ( None , title = \"Density\" , description = \"Density in grams per cm^3.\" ) density_atomic : float = Field ( None , title = \"Packing Density\" , description = \"The atomic packing density in atoms per cm^3.\" , ) symmetry : SymmetryData = Field ( None , description = \"Symmetry data for this material.\" ) @classmethod def from_composition ( cls : Type [ T ], composition : Composition , fields : Optional [ List [ str ]] = None , ** kwargs , ) -> T : fields = ( [ \"elements\" , \"nelements\" , \"composition\" , \"composition_reduced\" , \"formula_pretty\" , \"formula_anonymous\" , \"chemsys\" , ] if fields is None else fields ) composition = composition . remove_charges () elsyms = sorted ( set ([ e . symbol for e in composition . elements ])) data = { \"elements\" : elsyms , \"nelements\" : len ( elsyms ), \"composition\" : composition , \"composition_reduced\" : composition . reduced_composition . remove_charges (), \"formula_pretty\" : composition . reduced_formula , \"formula_anonymous\" : composition . anonymized_formula , \"chemsys\" : \"-\" . join ( elsyms ), } return cls ( ** { k : v for k , v in data . items () if k in fields }, ** kwargs ) @classmethod def from_structure ( cls : Type [ T ], meta_structure : Structure , fields : Optional [ List [ str ]] = None , ** kwargs , ) -> T : fields = ( [ \"nsites\" , \"elements\" , \"nelements\" , \"composition\" , \"composition_reduced\" , \"formula_pretty\" , \"formula_anonymous\" , \"chemsys\" , \"volume\" , \"density\" , \"density_atomic\" , \"symmetry\" , ] if fields is None else fields ) comp = meta_structure . composition . remove_charges () elsyms = sorted ( set ([ e . symbol for e in comp . elements ])) symmetry = SymmetryData . from_structure ( meta_structure ) data = { \"nsites\" : meta_structure . num_sites , \"elements\" : elsyms , \"nelements\" : len ( elsyms ), \"composition\" : comp , \"composition_reduced\" : comp . reduced_composition , \"formula_pretty\" : comp . reduced_formula , \"formula_anonymous\" : comp . anonymized_formula , \"chemsys\" : \"-\" . join ( elsyms ), \"volume\" : meta_structure . volume , \"density\" : meta_structure . density , \"density_atomic\" : meta_structure . volume / meta_structure . num_sites , \"symmetry\" : symmetry , } return cls ( ** { k : v for k , v in data . items () if k in fields }, ** kwargs )","title":"StructureMetadata"},{"location":"core/#emmet.core.structure.StructureMetadata.chemsys","text":"dash-delimited string of elements in the material.","title":"chemsys"},{"location":"core/#emmet.core.structure.StructureMetadata.composition","text":"Full composition for the material.","title":"composition"},{"location":"core/#emmet.core.structure.StructureMetadata.composition_reduced","text":"Simplified representation of the composition.","title":"composition_reduced"},{"location":"core/#emmet.core.structure.StructureMetadata.density","text":"Density in grams per cm^3.","title":"density"},{"location":"core/#emmet.core.structure.StructureMetadata.density_atomic","text":"The atomic packing density in atoms per cm^3.","title":"density_atomic"},{"location":"core/#emmet.core.structure.StructureMetadata.elements","text":"List of elements in the material.","title":"elements"},{"location":"core/#emmet.core.structure.StructureMetadata.formula_anonymous","text":"Anonymized representation of the formula.","title":"formula_anonymous"},{"location":"core/#emmet.core.structure.StructureMetadata.formula_pretty","text":"Cleaned representation of the formula.","title":"formula_pretty"},{"location":"core/#emmet.core.structure.StructureMetadata.nelements","text":"Number of elements.","title":"nelements"},{"location":"core/#emmet.core.structure.StructureMetadata.nsites","text":"Total number of sites in the structure.","title":"nsites"},{"location":"core/#emmet.core.structure.StructureMetadata.symmetry","text":"Symmetry data for this material.","title":"symmetry"},{"location":"core/#emmet.core.structure.StructureMetadata.volume","text":"Total volume for this structure in Angstroms^3. Core definition of a Materials Document","title":"volume"},{"location":"core/#emmet.core.material.MaterialsDoc","text":"Definition for a core Materials Document Source code in core/material.py class MaterialsDoc ( StructureMetadata ): \"\"\" Definition for a core Materials Document \"\"\" # Only material_id is required for all documents material_id : MPID = Field ( ... , description = \"The Materials Project ID of the material, used as a universal reference across property documents.\" \"This comes in the form: mp-******.\" , ) structure : Structure = Field ( ... , description = \"The structure of the this material.\" , ) deprecated : bool = Field ( True , description = \"Whether this materials document is deprecated.\" , ) deprecation_reasons : List [ Union [ DeprecationMessage , str ]] = Field ( None , description = \"List of deprecation tags detailing why this materials document isn't valid.\" , ) initial_structures : List [ Structure ] = Field ( [], description = \"Initial structures used in the DFT optimizations corresponding to this material.\" , ) task_ids : List [ MPID ] = Field ( [], description = \"List of Calculations IDs used to make this Materials Document.\" , ) deprecated_tasks : List [ str ] = Field ([], title = \"Deprecated Tasks\" ) calc_types : Mapping [ str , str ] = Field ( None , description = \"Calculation types for all the calculations that make up this material.\" , ) last_updated : datetime = Field ( description = \"Timestamp for when this document was last updated.\" , default_factory = datetime . utcnow , ) created_at : datetime = Field ( description = \"Timestamp for when this material document was first created.\" , default_factory = datetime . utcnow , ) origins : List [ PropertyOrigin ] = Field ( None , description = \"Dictionary for tracking the provenance of properties.\" ) warnings : List [ str ] = Field ( [], description = \"Any warnings related to this material.\" ) @classmethod def from_structure ( cls : Type [ T ], structure : Structure , material_id : MPID , ** kwargs ) -> T : # type: ignore[override] \"\"\" Builds a materials document using the minimal amount of information \"\"\" return super () . from_structure ( # type: ignore meta_structure = structure , material_id = material_id , structure = structure , ** kwargs , )","title":"MaterialsDoc"},{"location":"core/#emmet.core.material.MaterialsDoc.calc_types","text":"Calculation types for all the calculations that make up this material.","title":"calc_types"},{"location":"core/#emmet.core.material.MaterialsDoc.created_at","text":"Timestamp for when this material document was first created.","title":"created_at"},{"location":"core/#emmet.core.material.MaterialsDoc.deprecated","text":"Whether this materials document is deprecated.","title":"deprecated"},{"location":"core/#emmet.core.material.MaterialsDoc.deprecation_reasons","text":"List of deprecation tags detailing why this materials document isn't valid.","title":"deprecation_reasons"},{"location":"core/#emmet.core.material.MaterialsDoc.initial_structures","text":"Initial structures used in the DFT optimizations corresponding to this material.","title":"initial_structures"},{"location":"core/#emmet.core.material.MaterialsDoc.last_updated","text":"Timestamp for when this document was last updated.","title":"last_updated"},{"location":"core/#emmet.core.material.MaterialsDoc.material_id","text":"The Materials Project ID of the material, used as a universal reference across property documents.This comes in the form: mp- * *.","title":"material_id"},{"location":"core/#emmet.core.material.MaterialsDoc.origins","text":"Dictionary for tracking the provenance of properties.","title":"origins"},{"location":"core/#emmet.core.material.MaterialsDoc.structure","text":"The structure of the this material.","title":"structure"},{"location":"core/#emmet.core.material.MaterialsDoc.task_ids","text":"List of Calculations IDs used to make this Materials Document.","title":"task_ids"},{"location":"core/#emmet.core.material.MaterialsDoc.warnings","text":"Any warnings related to this material.","title":"warnings"},{"location":"core/#emmet.core.material.MaterialsDoc.from_structure","text":"Builds a materials document using the minimal amount of information Source code in core/material.py @classmethod def from_structure ( cls : Type [ T ], structure : Structure , material_id : MPID , ** kwargs ) -> T : # type: ignore[override] \"\"\" Builds a materials document using the minimal amount of information \"\"\" return super () . from_structure ( # type: ignore meta_structure = structure , material_id = material_id , structure = structure , ** kwargs , )","title":"from_structure()"},{"location":"core/#emmet.core.material.MoleculeDoc","text":"Definition for a core Molecule Document Source code in core/material.py class MoleculeDoc ( MoleculeMetadata ): \"\"\" Definition for a core Molecule Document \"\"\" # Only molecule_id is required for all documents molecule_id : MPID = Field ( ... , description = \"The ID of this molecule, used as a universal reference across property documents.\" \"This comes in the form of an MPID or int\" , ) molecule : Molecule = Field ( ... , description = \"The best (typically meaning lowest in energy) structure for this molecule\" , ) deprecated : bool = Field ( True , description = \"Whether this molecule document is deprecated.\" , ) # TODO: Why might a molecule be deprecated? deprecation_reasons : List [ str ] = Field ( None , description = \"List of deprecation tags detailing why this molecules document isn't valid\" , ) initial_molecules : List [ Molecule ] = Field ( [], description = \"Initial molecules used in the DFT geometry optimizations corresponding to this molecule\" , ) task_ids : List [ MPID ] = Field ( [], title = \"Calculation IDs\" , description = \"List of Calculations IDs used to make this Molecule Document\" , ) # TODO: Should this be MPID? deprecated_tasks : List [ str ] = Field ([], title = \"Deprecated Tasks\" ) calc_types : Mapping [ str , str ] = Field ( None , description = \"Calculation types for all the tasks that make up this molecule\" , ) last_updated : datetime = Field ( description = \"Timestamp for when this document was last updated\" , default_factory = datetime . utcnow , ) created_at : datetime = Field ( description = \"Timestamp for when this document was first created\" , default_factory = datetime . utcnow , ) origins : List [ PropertyOrigin ] = Field ( None , description = \"Dictionary for tracking the provenance of properties\" ) warnings : List [ str ] = Field ([], description = \"Any warnings related to this molecule\" ) @classmethod def from_molecule ( cls : Type [ S ], molecule : Molecule , molecule_id : MPID , ** kwargs ) -> S : # type: ignore[override] \"\"\" Builds a molecule document using the minimal amount of information \"\"\" return super () . from_molecule ( # type: ignore meta_molecule = molecule , molecule_id = molecule_id , molecule = molecule , ** kwargs )","title":"MoleculeDoc"},{"location":"core/#emmet.core.material.MoleculeDoc.calc_types","text":"Calculation types for all the tasks that make up this molecule","title":"calc_types"},{"location":"core/#emmet.core.material.MoleculeDoc.created_at","text":"Timestamp for when this document was first created","title":"created_at"},{"location":"core/#emmet.core.material.MoleculeDoc.deprecated","text":"Whether this molecule document is deprecated.","title":"deprecated"},{"location":"core/#emmet.core.material.MoleculeDoc.deprecation_reasons","text":"List of deprecation tags detailing why this molecules document isn't valid","title":"deprecation_reasons"},{"location":"core/#emmet.core.material.MoleculeDoc.initial_molecules","text":"Initial molecules used in the DFT geometry optimizations corresponding to this molecule","title":"initial_molecules"},{"location":"core/#emmet.core.material.MoleculeDoc.last_updated","text":"Timestamp for when this document was last updated","title":"last_updated"},{"location":"core/#emmet.core.material.MoleculeDoc.molecule","text":"The best (typically meaning lowest in energy) structure for this molecule","title":"molecule"},{"location":"core/#emmet.core.material.MoleculeDoc.molecule_id","text":"The ID of this molecule, used as a universal reference across property documents.This comes in the form of an MPID or int","title":"molecule_id"},{"location":"core/#emmet.core.material.MoleculeDoc.origins","text":"Dictionary for tracking the provenance of properties","title":"origins"},{"location":"core/#emmet.core.material.MoleculeDoc.task_ids","text":"List of Calculations IDs used to make this Molecule Document","title":"task_ids"},{"location":"core/#emmet.core.material.MoleculeDoc.warnings","text":"Any warnings related to this molecule","title":"warnings"},{"location":"core/#emmet.core.material.MoleculeDoc.from_molecule","text":"Builds a molecule document using the minimal amount of information Source code in core/material.py @classmethod def from_molecule ( cls : Type [ S ], molecule : Molecule , molecule_id : MPID , ** kwargs ) -> S : # type: ignore[override] \"\"\" Builds a molecule document using the minimal amount of information \"\"\" return super () . from_molecule ( # type: ignore meta_molecule = molecule , molecule_id = molecule_id , molecule = molecule , ** kwargs )","title":"from_molecule()"},{"location":"core/#emmet.core.material.PropertyOrigin","text":"Provenance document for the origin of properties in a material document Source code in core/material.py class PropertyOrigin ( BaseModel ): \"\"\" Provenance document for the origin of properties in a material document \"\"\" name : str = Field ( ... , description = \"The property name\" ) task_id : MPID = Field ( ... , description = \"The calculation ID this property comes from\" ) last_updated : datetime = Field ( description = \"The timestamp when this calculation was last updated\" , default_factory = datetime . utcnow , )","title":"PropertyOrigin"},{"location":"core/#emmet.core.material.PropertyOrigin.last_updated","text":"The timestamp when this calculation was last updated","title":"last_updated"},{"location":"core/#emmet.core.material.PropertyOrigin.name","text":"The property name","title":"name"},{"location":"core/#emmet.core.material.PropertyOrigin.task_id","text":"The calculation ID this property comes from Core definition of a Thermo Document","title":"task_id"},{"location":"core/#emmet.core.thermo.DecompositionProduct","text":"Entry metadata for a decomposition process Source code in core/thermo.py class DecompositionProduct ( BaseModel ): \"\"\" Entry metadata for a decomposition process \"\"\" material_id : MPID = Field ( None , description = \"The Materials Project ID for the material this decomposition points to.\" , ) formula : str = Field ( None , description = \"The formula of the decomposed material this material decomposes to.\" , ) amount : float = Field ( None , description = \"The amount of the decomposed material by formula units this this material decomposes to.\" , )","title":"DecompositionProduct"},{"location":"core/#emmet.core.thermo.DecompositionProduct.amount","text":"The amount of the decomposed material by formula units this this material decomposes to.","title":"amount"},{"location":"core/#emmet.core.thermo.DecompositionProduct.formula","text":"The formula of the decomposed material this material decomposes to.","title":"formula"},{"location":"core/#emmet.core.thermo.DecompositionProduct.material_id","text":"The Materials Project ID for the material this decomposition points to.","title":"material_id"},{"location":"core/#emmet.core.thermo.PhaseDiagramDoc","text":"A phase diagram document Source code in core/thermo.py class PhaseDiagramDoc ( BaseModel ): \"\"\" A phase diagram document \"\"\" property_name = \"phase_diagram\" chemsys : str = Field ( ... , title = \"Chemical System\" , description = \"Dash-delimited string of elements in the material\" , ) phase_diagram : PhaseDiagram = Field ( ... , description = \"Phase diagram for the chemical system.\" , ) last_updated : datetime = Field ( description = \"Timestamp for the most recent calculation update for this property\" , default_factory = datetime . utcnow , )","title":"PhaseDiagramDoc"},{"location":"core/#emmet.core.thermo.PhaseDiagramDoc.chemsys","text":"Dash-delimited string of elements in the material","title":"chemsys"},{"location":"core/#emmet.core.thermo.PhaseDiagramDoc.last_updated","text":"Timestamp for the most recent calculation update for this property","title":"last_updated"},{"location":"core/#emmet.core.thermo.PhaseDiagramDoc.phase_diagram","text":"Phase diagram for the chemical system.","title":"phase_diagram"},{"location":"core/#emmet.core.thermo.ThermoDoc","text":"A thermo entry document Source code in core/thermo.py class ThermoDoc ( PropertyDoc ): \"\"\" A thermo entry document \"\"\" property_name = \"thermo\" uncorrected_energy_per_atom : float = Field ( ... , description = \"The total DFT energy of this material per atom in eV/atom.\" ) energy_per_atom : float = Field ( ... , description = \"The total corrected DFT energy of this material per atom in eV/atom.\" , ) energy_uncertainy_per_atom : float = Field ( None , description = \"\" ) formation_energy_per_atom : float = Field ( None , description = \"The formation energy per atom in eV/atom.\" ) energy_above_hull : float = Field ( ... , description = \"The energy above the hull in eV/Atom.\" ) is_stable : bool = Field ( False , description = \"Flag for whether this material is on the hull and therefore stable.\" , ) equilibrium_reaction_energy_per_atom : float = Field ( None , description = \"The reaction energy of a stable entry from the neighboring equilibrium stable materials in eV.\" \" Also known as the inverse distance to hull.\" , ) decomposes_to : List [ DecompositionProduct ] = Field ( None , description = \"List of decomposition data for this material. Only valid for metastable or unstable material.\" , ) decomposition_enthalpy : float = Field ( None , description = \"Decomposition enthalpy as defined by `get_decomp_and_phase_separation_energy` in pymatgen.\" , ) decomposition_enthalpy_decomposes_to : List [ DecompositionProduct ] = Field ( None , description = \"List of decomposition data associated with the decomposition_enthalpy quantity.\" , ) energy_type : str = Field ( ... , description = \"The type of calculation this energy evaluation comes from.\" , ) entry_types : List [ str ] = Field ( description = \"List of available energy types computed for this material.\" ) entries : Dict [ str , Union [ ComputedEntry , ComputedStructureEntry ]] = Field ( ... , description = \"List of all entries that are valid for this material.\" \" The keys for this dictionary are names of various calculation types.\" , ) @classmethod def from_entries ( cls , entries : List [ Union [ ComputedEntry , ComputedStructureEntry ]], ** kwargs ): entries_by_comp = defaultdict ( list ) for e in entries : entries_by_comp [ e . composition . reduced_formula ] . append ( e ) # Only use lowest entry per composition to speed up QHull in Phase Diagram reduced_entries = [ sorted ( comp_entries , key = lambda e : e . energy_per_atom )[ 0 ] for comp_entries in entries_by_comp . values () ] pd = PhaseDiagram ( reduced_entries ) docs = [] entries_by_mpid = defaultdict ( list ) for e in entries : entries_by_mpid [ e . data [ \"material_id\" ]] . append ( e ) entry_quality_scores = { \"GGA\" : 1 , \"GGA+U\" : 2 , \"SCAN\" : 3 , \"R2SCAN\" : 4 } def _energy_eval ( entry : ComputedStructureEntry ): \"\"\" Helper function to order entries for thermo energy data selection - Run type - LASPH - Energy \"\"\" return ( - 1 * entry_quality_scores . get ( entry . data [ \"run_type\" ], 0 ), - 1 * int ( entry . data . get ( \"aspherical\" , False )), entry . energy , ) for material_id , entry_group in entries_by_mpid . items (): sorted_entries = sorted ( entry_group , key = _energy_eval ) blessed_entry = sorted_entries [ 0 ] ( decomp , ehull ) = pd . get_decomp_and_e_above_hull ( blessed_entry ) d = { \"material_id\" : material_id , \"uncorrected_energy_per_atom\" : blessed_entry . uncorrected_energy / blessed_entry . composition . num_atoms , \"energy_per_atom\" : blessed_entry . energy / blessed_entry . composition . num_atoms , \"formation_energy_per_atom\" : pd . get_form_energy_per_atom ( blessed_entry ), \"energy_above_hull\" : ehull , \"is_stable\" : blessed_entry in pd . stable_entries , } if \"last_updated\" in blessed_entry . data : d [ \"last_updated\" ] = blessed_entry . data [ \"last_updated\" ] # Store different info if stable vs decomposes if d [ \"is_stable\" ]: d [ \"equilibrium_reaction_energy_per_atom\" ] = pd . get_equilibrium_reaction_energy ( blessed_entry ) else : d [ \"decomposes_to\" ] = [ { \"material_id\" : de . data [ \"material_id\" ], \"formula\" : de . composition . formula , \"amount\" : amt , } for de , amt in decomp . items () ] try : decomp , energy = pd . get_decomp_and_phase_separation_energy ( blessed_entry ) d [ \"decomposition_enthalpy\" ] = energy d [ \"decomposition_enthalpy_decomposes_to\" ] = [ { \"material_id\" : de . data [ \"material_id\" ], \"formula\" : de . composition . formula , \"amount\" : amt , } for de , amt in decomp . items () ] except ValueError : # try/except so this quantity does not take down the builder if it fails: # it includes an optimization step that can be fragile in some instances, # most likely failure is ValueError, \"invalid value encountered in true_divide\" d [ \"warnings\" ] = [ \"Could not calculate decomposition enthalpy for this entry.\" ] d [ \"energy_type\" ] = blessed_entry . parameters . get ( \"run_type\" , \"Unknown\" ) d [ \"entry_types\" ] = [] d [ \"entries\" ] = {} # Currently, each entry group contains a single entry due to how the compatability scheme works for entry in entry_group : d [ \"entry_types\" ] . append ( entry . parameters . get ( \"run_type\" , \"Unknown\" )) d [ \"entries\" ][ entry . parameters . get ( \"run_type\" , \"Unknown\" )] = entry d [ \"origins\" ] = [ PropertyOrigin ( name = \"energy\" , task_id = blessed_entry . data [ \"task_id\" ], last_updated = d . get ( \"last_updated\" , datetime . utcnow ()), ) ] docs . append ( ThermoDoc . from_structure ( meta_structure = blessed_entry . structure , ** d , ** kwargs ) ) # Construct new phase diagram with all of the entries, not just those on the hull pd_computed_data = pd . _compute () pd_computed_data [ \"all_entries\" ] = entries new_pd = PhaseDiagram ( entries , elements = pd . elements , computed_data = pd_computed_data ) return docs , new_pd","title":"ThermoDoc"},{"location":"core/#emmet.core.thermo.ThermoDoc.decomposes_to","text":"List of decomposition data for this material. Only valid for metastable or unstable material.","title":"decomposes_to"},{"location":"core/#emmet.core.thermo.ThermoDoc.decomposition_enthalpy","text":"Decomposition enthalpy as defined by get_decomp_and_phase_separation_energy in pymatgen.","title":"decomposition_enthalpy"},{"location":"core/#emmet.core.thermo.ThermoDoc.decomposition_enthalpy_decomposes_to","text":"List of decomposition data associated with the decomposition_enthalpy quantity.","title":"decomposition_enthalpy_decomposes_to"},{"location":"core/#emmet.core.thermo.ThermoDoc.energy_above_hull","text":"The energy above the hull in eV/Atom.","title":"energy_above_hull"},{"location":"core/#emmet.core.thermo.ThermoDoc.energy_per_atom","text":"The total corrected DFT energy of this material per atom in eV/atom.","title":"energy_per_atom"},{"location":"core/#emmet.core.thermo.ThermoDoc.energy_type","text":"The type of calculation this energy evaluation comes from.","title":"energy_type"},{"location":"core/#emmet.core.thermo.ThermoDoc.entries","text":"List of all entries that are valid for this material. The keys for this dictionary are names of various calculation types.","title":"entries"},{"location":"core/#emmet.core.thermo.ThermoDoc.entry_types","text":"List of available energy types computed for this material.","title":"entry_types"},{"location":"core/#emmet.core.thermo.ThermoDoc.equilibrium_reaction_energy_per_atom","text":"The reaction energy of a stable entry from the neighboring equilibrium stable materials in eV. Also known as the inverse distance to hull.","title":"equilibrium_reaction_energy_per_atom"},{"location":"core/#emmet.core.thermo.ThermoDoc.formation_energy_per_atom","text":"The formation energy per atom in eV/atom.","title":"formation_energy_per_atom"},{"location":"core/#emmet.core.thermo.ThermoDoc.is_stable","text":"Flag for whether this material is on the hull and therefore stable.","title":"is_stable"},{"location":"core/#emmet.core.thermo.ThermoDoc.uncorrected_energy_per_atom","text":"The total DFT energy of this material per atom in eV/atom. Core definition of a Provenance Document","title":"uncorrected_energy_per_atom"},{"location":"core/#emmet.core.provenance.Author","text":"Author information Source code in core/provenance.py class Author ( BaseModel ): \"\"\" Author information \"\"\" name : str = Field ( None ) email : str = Field ( None )","title":"Author"},{"location":"core/#emmet.core.provenance.Database","text":"Database identifiers for provenance IDs Source code in core/provenance.py class Database ( ValueEnum ): \"\"\" Database identifiers for provenance IDs \"\"\" ICSD = \"icsd\" Pauling_Files = \"pf\" COD = \"cod\"","title":"Database"},{"location":"core/#emmet.core.provenance.History","text":"History of the material provenance Source code in core/provenance.py class History ( BaseModel ): \"\"\" History of the material provenance \"\"\" name : str url : str description : Optional [ Dict ] = Field ( None , description = \"Dictionary of exra data for this history node.\" ) @root_validator ( pre = True ) def str_to_dict ( cls , values ): if isinstance ( values . get ( \"description\" ), str ): values [ \"description\" ] = { \"string\" : values . get ( \"description\" )} return values","title":"History"},{"location":"core/#emmet.core.provenance.History.description","text":"Dictionary of exra data for this history node.","title":"description"},{"location":"core/#emmet.core.provenance.ProvenanceDoc","text":"A provenance property block Source code in core/provenance.py class ProvenanceDoc ( PropertyDoc ): \"\"\" A provenance property block \"\"\" property_name = \"provenance\" created_at : datetime = Field ( ... , description = \"creation date for the first structure corresponding to this material\" , ) references : List [ str ] = Field ( [], description = \"Bibtex reference strings for this material\" ) authors : List [ Author ] = Field ([], description = \"List of authors for this material\" ) remarks : List [ str ] = Field ( [], description = \"List of remarks for the provenance of this material\" ) tags : List [ str ] = Field ([]) theoretical : bool = Field ( True , description = \"If this material has any experimental provenance or not\" ) database_IDs : Dict [ Database , List [ str ]] = Field ( dict (), description = \"Database IDs corresponding to this material\" ) history : List [ History ] = Field ( [], description = \"List of history nodes specifying the transformations or orignation\" \" of this material for the entry closest matching the material input\" , ) @validator ( \"authors\" ) def remove_duplicate_authors ( cls , authors ): authors_dict = { entry . name . lower (): entry for entry in authors } return list ( authors_dict . values ()) @classmethod def from_SNLs ( cls , material_id : MPID , structure : Structure , snls : List [ SNLDict ], ** kwargs ) -> \"ProvenanceDoc\" : \"\"\" Converts legacy Pymatgen SNLs into a single provenance document \"\"\" assert ( len ( snls ) > 0 ), \"Error must provide a non-zero list of SNLs to convert from SNLs\" # Choose earliest created_at created_at = min ([ snl . about . created_at for snl in snls ]) # last_updated = max([snl.about.created_at for snl in snls]) # Choose earliest history history = sorted ( snls , key = lambda snl : snl . about . created_at )[ 0 ] . about . history # Aggregate all references into one dict to remove duplicates refs = {} for snl in snls : try : set_strict_mode ( False ) entries = parse_string ( snl . about . references , bib_format = \"bibtex\" ) refs . update ( entries . entries ) except Exception as e : warnings . warn ( f \"Failed parsing bibtex: { snl . about . references } due to { e } \" ) bib_data = BibliographyData ( entries = refs ) references = [ ref . to_string ( \"bibtex\" ) for ref in bib_data . entries . values ()] # TODO: Maybe we should combine this robocrystallographer? # TODO: Refine these tags / remarks remarks = list ( set ([ remark for snl in snls for remark in snl . about . remarks ])) tags = [ r for r in remarks if len ( r ) < 140 ] authors = [ entry for snl in snls for entry in snl . about . authors ] # Check if this entry is experimental exp_vals = [] for snl in snls : for entry in snl . about . history : if entry . description is not None : exp_vals . append ( entry . description . get ( \"experimental\" , False )) experimental = any ( exp_vals ) # Aggregate all the database IDs snl_ids = { snl . snl_id for snl in snls } db_ids = { Database ( db_id ): [ snl_id for snl_id in snl_ids if db_id in snl_id ] for db_id in map ( str , Database ) # type: ignore } # remove Nones and empty lists db_ids = { k : list ( filter ( None , v )) for k , v in db_ids . items ()} db_ids = { k : v for k , v in db_ids . items () if len ( v ) > 0 } fields = { \"created_at\" : created_at , \"references\" : references , \"authors\" : authors , \"remarks\" : remarks , \"tags\" : tags , \"database_IDs\" : db_ids , \"theoretical\" : not experimental , \"history\" : history , } return super () . from_structure ( material_id = material_id , meta_structure = structure , ** fields , ** kwargs )","title":"ProvenanceDoc"},{"location":"core/#emmet.core.provenance.ProvenanceDoc.authors","text":"List of authors for this material","title":"authors"},{"location":"core/#emmet.core.provenance.ProvenanceDoc.created_at","text":"creation date for the first structure corresponding to this material","title":"created_at"},{"location":"core/#emmet.core.provenance.ProvenanceDoc.database_IDs","text":"Database IDs corresponding to this material","title":"database_IDs"},{"location":"core/#emmet.core.provenance.ProvenanceDoc.history","text":"List of history nodes specifying the transformations or orignation of this material for the entry closest matching the material input","title":"history"},{"location":"core/#emmet.core.provenance.ProvenanceDoc.references","text":"Bibtex reference strings for this material","title":"references"},{"location":"core/#emmet.core.provenance.ProvenanceDoc.remarks","text":"List of remarks for the provenance of this material","title":"remarks"},{"location":"core/#emmet.core.provenance.ProvenanceDoc.theoretical","text":"If this material has any experimental provenance or not","title":"theoretical"},{"location":"core/#emmet.core.provenance.ProvenanceDoc.from_SNLs","text":"Converts legacy Pymatgen SNLs into a single provenance document Source code in core/provenance.py @classmethod def from_SNLs ( cls , material_id : MPID , structure : Structure , snls : List [ SNLDict ], ** kwargs ) -> \"ProvenanceDoc\" : \"\"\" Converts legacy Pymatgen SNLs into a single provenance document \"\"\" assert ( len ( snls ) > 0 ), \"Error must provide a non-zero list of SNLs to convert from SNLs\" # Choose earliest created_at created_at = min ([ snl . about . created_at for snl in snls ]) # last_updated = max([snl.about.created_at for snl in snls]) # Choose earliest history history = sorted ( snls , key = lambda snl : snl . about . created_at )[ 0 ] . about . history # Aggregate all references into one dict to remove duplicates refs = {} for snl in snls : try : set_strict_mode ( False ) entries = parse_string ( snl . about . references , bib_format = \"bibtex\" ) refs . update ( entries . entries ) except Exception as e : warnings . warn ( f \"Failed parsing bibtex: { snl . about . references } due to { e } \" ) bib_data = BibliographyData ( entries = refs ) references = [ ref . to_string ( \"bibtex\" ) for ref in bib_data . entries . values ()] # TODO: Maybe we should combine this robocrystallographer? # TODO: Refine these tags / remarks remarks = list ( set ([ remark for snl in snls for remark in snl . about . remarks ])) tags = [ r for r in remarks if len ( r ) < 140 ] authors = [ entry for snl in snls for entry in snl . about . authors ] # Check if this entry is experimental exp_vals = [] for snl in snls : for entry in snl . about . history : if entry . description is not None : exp_vals . append ( entry . description . get ( \"experimental\" , False )) experimental = any ( exp_vals ) # Aggregate all the database IDs snl_ids = { snl . snl_id for snl in snls } db_ids = { Database ( db_id ): [ snl_id for snl_id in snl_ids if db_id in snl_id ] for db_id in map ( str , Database ) # type: ignore } # remove Nones and empty lists db_ids = { k : list ( filter ( None , v )) for k , v in db_ids . items ()} db_ids = { k : v for k , v in db_ids . items () if len ( v ) > 0 } fields = { \"created_at\" : created_at , \"references\" : references , \"authors\" : authors , \"remarks\" : remarks , \"tags\" : tags , \"database_IDs\" : db_ids , \"theoretical\" : not experimental , \"history\" : history , } return super () . from_structure ( material_id = material_id , meta_structure = structure , ** fields , ** kwargs )","title":"from_SNLs()"},{"location":"core/#emmet.core.provenance.SNLAbout","text":"A data dictionary definining extra fields in a SNL Source code in core/provenance.py class SNLAbout ( BaseModel ): \"\"\"A data dictionary definining extra fields in a SNL\"\"\" references : str = Field ( \"\" , description = \"Bibtex reference strings for this material.\" ) authors : List [ Author ] = Field ([], description = \"List of authors for this material.\" ) remarks : List [ str ] = Field ( [], description = \"List of remarks for the provenance of this material.\" ) tags : List [ str ] = Field ([]) database_IDs : Dict [ Database , List [ str ]] = Field ( dict (), description = \"Database IDs corresponding to this material.\" ) history : List [ History ] = Field ( [], description = \"List of history nodes specifying the transformations or orignation\" \" of this material for the entry closest matching the material input.\" , ) created_at : datetime = Field ( default_factory = datetime . utcnow , description = \"The creation date for this SNL.\" ) @validator ( \"created_at\" , pre = True ) def convert_monty_date ( cls , v ): if isinstance ( v , dict ): if v . get ( \"@module\" , \"datetime\" ) and v . get ( \"@class\" , \"datetime\" ): return datetime . fromisoformat ( v [ \"string\" ]) raise ValueError ( \"Improper monty dict datetime\" ) return v","title":"SNLAbout"},{"location":"core/#emmet.core.provenance.SNLAbout.authors","text":"List of authors for this material.","title":"authors"},{"location":"core/#emmet.core.provenance.SNLAbout.created_at","text":"The creation date for this SNL.","title":"created_at"},{"location":"core/#emmet.core.provenance.SNLAbout.database_IDs","text":"Database IDs corresponding to this material.","title":"database_IDs"},{"location":"core/#emmet.core.provenance.SNLAbout.history","text":"List of history nodes specifying the transformations or orignation of this material for the entry closest matching the material input.","title":"history"},{"location":"core/#emmet.core.provenance.SNLAbout.references","text":"Bibtex reference strings for this material.","title":"references"},{"location":"core/#emmet.core.provenance.SNLAbout.remarks","text":"List of remarks for the provenance of this material.","title":"remarks"},{"location":"core/#emmet.core.provenance.SNLDict","text":"Pydantic validated dictionary for SNL Source code in core/provenance.py class SNLDict ( BaseModel ): \"\"\"Pydantic validated dictionary for SNL\"\"\" about : SNLAbout snl_id : str = Field ( ... , description = \"The SNL ID for this entry\" )","title":"SNLDict"},{"location":"core/#emmet.core.provenance.SNLDict.snl_id","text":"The SNL ID for this entry Core definition for Polar property Document","title":"snl_id"},{"location":"core/#emmet.core.polar.DielectricDoc","text":"A dielectric property block Source code in core/polar.py class DielectricDoc ( PropertyDoc ): \"\"\" A dielectric property block \"\"\" property_name = \"dielectric\" total : Matrix3D = Field ( description = \"Total dielectric tensor.\" ) ionic : Matrix3D = Field ( description = \"Ionic contribution to dielectric tensor.\" ) electronic : Matrix3D = Field ( description = \"Electronic contribution to dielectric tensor.\" ) e_total : float = Field ( description = \"Total electric permittivity.\" ) e_ionic : float = Field ( description = \"Electric permittivity from atomic rearrangement.\" ) e_electronic : float = Field ( description = \"Electric permittivity due to electrons rearrangement.\" ) n : float = Field ( description = \"Refractive index.\" ) @classmethod def from_ionic_and_electronic ( cls , material_id : MPID , ionic : Matrix3D , electronic : Matrix3D , structure : Structure , ** kwargs , ): ionic_tensor = Tensor ( ionic ) . convert_to_ieee ( structure ) electronic_tensor = Tensor ( electronic ) . convert_to_ieee ( structure ) total = ionic_tensor + electronic_tensor return super () . from_structure ( meta_structure = structure , material_id = material_id , ** { \"total\" : total . tolist (), \"ionic\" : ionic_tensor . tolist (), \"electronic\" : electronic_tensor . tolist (), \"e_total\" : np . average ( np . diagonal ( total )), \"e_ionic\" : np . average ( np . diagonal ( ionic_tensor )), \"e_electronic\" : np . average ( np . diagonal ( electronic_tensor )), \"n\" : np . sqrt ( np . average ( np . diagonal ( electronic_tensor ))), }, ** kwargs , )","title":"DielectricDoc"},{"location":"core/#emmet.core.polar.DielectricDoc.e_electronic","text":"Electric permittivity due to electrons rearrangement.","title":"e_electronic"},{"location":"core/#emmet.core.polar.DielectricDoc.e_ionic","text":"Electric permittivity from atomic rearrangement.","title":"e_ionic"},{"location":"core/#emmet.core.polar.DielectricDoc.e_total","text":"Total electric permittivity.","title":"e_total"},{"location":"core/#emmet.core.polar.DielectricDoc.electronic","text":"Electronic contribution to dielectric tensor.","title":"electronic"},{"location":"core/#emmet.core.polar.DielectricDoc.ionic","text":"Ionic contribution to dielectric tensor.","title":"ionic"},{"location":"core/#emmet.core.polar.DielectricDoc.n","text":"Refractive index.","title":"n"},{"location":"core/#emmet.core.polar.DielectricDoc.total","text":"Total dielectric tensor.","title":"total"},{"location":"core/#emmet.core.polar.PiezoelectricDoc","text":"A dielectric package block Source code in core/polar.py class PiezoelectricDoc ( PropertyDoc ): \"\"\" A dielectric package block \"\"\" property_name = \"piezoelectric\" total : PiezoTensor = Field ( description = \"Total piezoelectric tensor in C/m\u00b2\" ) ionic : PiezoTensor = Field ( description = \"Ionic contribution to piezoelectric tensor in C/m\u00b2\" ) electronic : PiezoTensor = Field ( description = \"Electronic contribution to piezoelectric tensor in C/m\u00b2\" ) e_ij_max : float = Field ( description = \"Piezoelectric modulus\" ) max_direction : List [ int ] = Field ( description = \"Miller direction for maximum piezo response\" ) strain_for_max : List [ float ] = Field ( description = \"Normalized strain direction for maximum piezo repsonse\" ) @classmethod def from_ionic_and_electronic ( cls , material_id : MPID , ionic : PiezoTensor , electronic : PiezoTensor , structure : Structure , ** kwargs , ): ionic_tensor = BasePiezoTensor . from_vasp_voigt ( ionic ) electronic_tensor = BasePiezoTensor . from_vasp_voigt ( electronic ) total = ionic_tensor + electronic_tensor # Symmeterize Convert to IEEE orientation total = total . convert_to_ieee ( structure ) ionic_tensor = ionic_tensor . convert_to_ieee ( structure ) electronic_tensor = electronic_tensor . convert_to_ieee ( structure ) directions , charges , strains = np . linalg . svd ( total . voigt , full_matrices = False ) max_index = np . argmax ( np . abs ( charges )) max_direction = directions [ max_index ] # Allow a max miller index of 10 min_val = np . abs ( max_direction ) min_val = min_val [ min_val > ( np . max ( min_val ) / SETTINGS . MAX_PIEZO_MILLER )] min_val = np . min ( min_val ) return super () . from_structure ( meta_structure = structure , material_id = material_id , ** { \"total\" : total . zeroed () . voigt . tolist (), \"ionic\" : ionic_tensor . zeroed () . voigt . tolist (), \"electronic\" : electronic_tensor . zeroed () . voigt . tolist (), \"e_ij_max\" : charges [ max_index ], \"max_direction\" : tuple ( np . round ( max_direction / min_val )), \"strain_for_max\" : tuple ( strains [ max_index ]), }, ** kwargs , )","title":"PiezoelectricDoc"},{"location":"core/#emmet.core.polar.PiezoelectricDoc.e_ij_max","text":"Piezoelectric modulus","title":"e_ij_max"},{"location":"core/#emmet.core.polar.PiezoelectricDoc.electronic","text":"Electronic contribution to piezoelectric tensor in C/m\u00b2","title":"electronic"},{"location":"core/#emmet.core.polar.PiezoelectricDoc.ionic","text":"Ionic contribution to piezoelectric tensor in C/m\u00b2","title":"ionic"},{"location":"core/#emmet.core.polar.PiezoelectricDoc.max_direction","text":"Miller direction for maximum piezo response","title":"max_direction"},{"location":"core/#emmet.core.polar.PiezoelectricDoc.strain_for_max","text":"Normalized strain direction for maximum piezo repsonse","title":"strain_for_max"},{"location":"core/#emmet.core.polar.PiezoelectricDoc.total","text":"Total piezoelectric tensor in C/m\u00b2","title":"total"},{"location":"packages/","text":"Packages \u00b6 emmet is a toolkit of packages that are used in conjunction to create the Materials API (MAPI) from raw calculations on disk. The following package make up this toolkit. emmet-core \u00b6 This is the core package for the emmet ecosystem. emmet.core is where data models are defined. These data models are the most important part of emmet since they dictate what all the other packages have to use, serve, or compute. emmet-cli \u00b6 Many of the operations in emmet are complex. These range from backing up calculations, to parsing, to setting of build chains, to starting workflows. Since these processes are pretty standard, the emmet ecosystem provides a CLI implemented in emmet.cli . This makes managing MAPI much easier. emmet-builders \u00b6 The data served via MAPI has to computed via data pipelines. emmet.builders defines these operations using the maggma framework to enable well constructed data access, multi- and distributed processing, reporting, and automatic incremental computation.","title":"Packages"},{"location":"packages/#packages","text":"emmet is a toolkit of packages that are used in conjunction to create the Materials API (MAPI) from raw calculations on disk. The following package make up this toolkit.","title":"Packages"},{"location":"packages/#emmet-core","text":"This is the core package for the emmet ecosystem. emmet.core is where data models are defined. These data models are the most important part of emmet since they dictate what all the other packages have to use, serve, or compute.","title":"emmet-core"},{"location":"packages/#emmet-cli","text":"Many of the operations in emmet are complex. These range from backing up calculations, to parsing, to setting of build chains, to starting workflows. Since these processes are pretty standard, the emmet ecosystem provides a CLI implemented in emmet.cli . This makes managing MAPI much easier.","title":"emmet-cli"},{"location":"packages/#emmet-builders","text":"The data served via MAPI has to computed via data pipelines. emmet.builders defines these operations using the maggma framework to enable well constructed data access, multi- and distributed processing, reporting, and automatic incremental computation.","title":"emmet-builders"},{"location":"settings/","text":"Settings Management \u00b6 emmet has a flexible settings management system based on Pydantic's BaseSetting . A core EmmetSettings class is used to define a data model for settings. EmmetSettings will automatically use the emmet_config_path environment variable (defaults to $HOME/.emmet.json ) to load the settings for the whole emmet system. By inheriting from this class, any subpackage automatically gets this core loading feature. Example: from pydantic import Field from emmet.settings import EmmetSettings class MySettings ( EmmetSettings ): my_new_setting : int = Field ( 3 , description = \"A custom setting\" ) Now any instance of MySettings will automatically load the configuration file and use that to initialize this setting. Using the magic of pydantic BaseSettings , these settings can also be set using environment variables prefixed by EMMET_ . export EMMET_MY_NEW_SETTING = 4","title":"Settings"},{"location":"settings/#settings-management","text":"emmet has a flexible settings management system based on Pydantic's BaseSetting . A core EmmetSettings class is used to define a data model for settings. EmmetSettings will automatically use the emmet_config_path environment variable (defaults to $HOME/.emmet.json ) to load the settings for the whole emmet system. By inheriting from this class, any subpackage automatically gets this core loading feature. Example: from pydantic import Field from emmet.settings import EmmetSettings class MySettings ( EmmetSettings ): my_new_setting : int = Field ( 3 , description = \"A custom setting\" ) Now any instance of MySettings will automatically load the configuration file and use that to initialize this setting. Using the magic of pydantic BaseSettings , these settings can also be set using environment variables prefixed by EMMET_ . export EMMET_MY_NEW_SETTING = 4","title":"Settings Management"}]}